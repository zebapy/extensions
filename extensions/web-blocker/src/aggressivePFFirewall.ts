/**
 * Enhanced PF Firewall Manager - Aggressive Connection Termination
 * Kills existing connections IMMEDIATELY when blocking is enabled
 * No cache bypass possible - works at network layer
 */

import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs/promises";
import { executeScriptWithAuth } from "./biometricAuth";
import {
  escapeShellArg,
  isValidIP,
  sanitizeDomainForShell,
} from "./securityUtils";

const execAsync = promisify(exec);

// Constants
const PF_ANCHOR_NAME = "com.webblocker.blocking";
const PF_RULES_FILE = "/tmp/webblocker.pf.rules";
const PF_CONF = "/etc/pf.conf";

export interface FirewallResult {
  success: boolean;
  message: string;
  ipsBlocked?: number;
}

/**
 * Extract clean domain from input
 */
function extractDomain(input: string): string {
  let domain = input.toLowerCase().trim();
  domain = domain.replace(/^[a-z]+:\/\//, "");
  domain = domain.split("/")[0];
  domain = domain.split("?")[0];
  domain = domain.split("#")[0];
  domain = domain.split(":")[0];
  return domain;
}

/**
 * Resolve domains to ALL IP addresses (IPv4 and IPv6)
 */
async function resolveDomains(domains: string[]): Promise<string[]> {
  const ips: Set<string> = new Set();

  for (const domain of domains) {
    // Sanitize domain before using in shell command
    const sanitizedDomain = sanitizeDomainForShell(domain);
    if (!sanitizedDomain) {
      console.warn(`Skipping invalid domain: ${domain}`);
      continue;
    }

    try {
      // Resolve IPv4 - escape domain for shell safety
      const { stdout: ipv4 } = await execAsync(
        `dig +short ${escapeShellArg(sanitizedDomain)} A 2>/dev/null || true`,
      );
      ipv4.split("\n").forEach((ip) => {
        const trimmed = ip.trim();
        if (trimmed && isValidIP(trimmed)) {
          ips.add(trimmed);
        }
      });

      // Resolve IPv6 - escape domain for shell safety
      const { stdout: ipv6 } = await execAsync(
        `dig +short ${escapeShellArg(sanitizedDomain)} AAAA 2>/dev/null || true`,
      );
      ipv6.split("\n").forEach((ip) => {
        const trimmed = ip.trim();
        if (trimmed && isValidIP(trimmed)) {
          ips.add(trimmed);
        }
      });

      // Also try with www prefix if not already there
      if (!sanitizedDomain.startsWith("www.")) {
        const wwwDomain = `www.${sanitizedDomain}`;
        const { stdout: wwwIpv4 } = await execAsync(
          `dig +short ${escapeShellArg(wwwDomain)} A 2>/dev/null || true`,
        );
        wwwIpv4.split("\n").forEach((ip) => {
          const trimmed = ip.trim();
          if (trimmed && isValidIP(trimmed)) {
            ips.add(trimmed);
          }
        });
      }
    } catch (error) {
      console.error(`Failed to resolve ${domain}:`, error);
    }
  }

  return Array.from(ips);
}

/**
 * Generate aggressive PF rules that drop packets immediately
 */
async function generateAggressivePFRules(domains: string[]): Promise<string> {
  const uniqueDomains = Array.from(new Set(domains.map(extractDomain))).filter(
    Boolean,
  );

  const rules = `# WebBlocker Aggressive PF Rules
# Generated by Raycast WebBlocker Extension
# Blocks at TCP/IP layer - NO BYPASS POSSIBLE

# Table for blocked IPs
table <webblocker_blocked> persist

# BLOCK RULES - Drop packets immediately, no response
# "drop" = silently drop packets (no RST/ICMP response)
# "quick" = stop processing other rules immediately

# Block outgoing connections (initiated by this machine)
block drop out quick on any inet proto tcp from any to <webblocker_blocked>
block drop out quick on any inet proto udp from any to <webblocker_blocked>
block drop out quick on any inet6 proto tcp from any to <webblocker_blocked>
block drop out quick on any inet6 proto udp from any to <webblocker_blocked>

# Block incoming packets (for existing connections)
block drop in quick on any inet proto tcp from <webblocker_blocked> to any
block drop in quick on any inet proto udp from <webblocker_blocked> to any
block drop in quick on any inet6 proto tcp from <webblocker_blocked> to any
block drop in quick on any inet6 proto udp from <webblocker_blocked> to any

# Also block HTTPS (443) and HTTP (80) specifically
block drop out quick on any proto tcp from any to <webblocker_blocked> port 443
block drop out quick on any proto tcp from any to <webblocker_blocked> port 80

# Blocked domains: ${uniqueDomains.join(", ")}
`;

  return rules;
}

/**
 * Enable aggressive PF firewall blocking with immediate connection termination
 */
export async function enableAggressivePFBlocking(
  domains: string[],
): Promise<FirewallResult> {
  if (!domains || domains.length === 0) {
    return {
      success: false,
      message: "No domains provided to block",
    };
  }

  try {
    console.log(
      `üî• Enabling AGGRESSIVE PF firewall blocking for ${domains.length} domains...`,
    );

    // Step 1: Expand domains (www and non-www)
    const expandedDomains: string[] = [];
    domains.forEach((domain) => {
      const cleanDomain = extractDomain(domain);
      if (cleanDomain) {
        expandedDomains.push(cleanDomain);
        if (!cleanDomain.startsWith("www.")) {
          expandedDomains.push(`www.${cleanDomain}`);
        } else {
          expandedDomains.push(cleanDomain.replace(/^www\./, ""));
        }
      }
    });

    // Step 2: Resolve all domains to IPs
    console.log("üîç Resolving domains to IP addresses...");
    const resolvedIPs = await resolveDomains(expandedDomains);
    console.log(`‚úÖ Resolved ${resolvedIPs.length} IP addresses to block`);

    // Filter and validate IPs before using in shell commands
    const validIPs = resolvedIPs.filter((ip) => isValidIP(ip));
    console.log(`‚úÖ Validated ${validIPs.length} valid IP addresses`);

    if (validIPs.length === 0) {
      return {
        success: false,
        message: "Could not resolve any valid IPs for the provided domains",
      };
    }

    // Step 3: Generate aggressive PF rules
    const rules = await generateAggressivePFRules(domains);
    await fs.writeFile(PF_RULES_FILE, rules);

    // Step 4: Create installation script with properly escaped IPs
    const scriptContent = `#!/bin/bash
set -e

echo "üî• Setting up AGGRESSIVE PF firewall blocking..."

# Ensure PF is enabled first
if ! pfctl -s info 2>/dev/null | grep -q "Status: Enabled"; then
  echo "üöÄ Enabling PF firewall..."
  pfctl -e 2>/dev/null || true
fi

# Check if our anchor already exists in pf.conf
if ! grep -q "${PF_ANCHOR_NAME}" "${PF_CONF}" 2>/dev/null; then
  echo "üìù Adding WebBlocker anchor to pf.conf..."
  
  # Backup pf.conf
  cp "${PF_CONF}" "${PF_CONF}.webblocker.backup" 2>/dev/null || true
  
  # Add anchor
  echo "" >> "${PF_CONF}"
  echo "# WebBlocker Aggressive Blocking - DO NOT REMOVE" >> "${PF_CONF}"
  echo "anchor \\"${PF_ANCHOR_NAME}\\"" >> "${PF_CONF}"
  echo "load anchor \\"${PF_ANCHOR_NAME}\\" from \\"${PF_RULES_FILE}\\"" >> "${PF_CONF}"
  
  # Reload PF config
  pfctl -f "${PF_CONF}" 2>/dev/null || true
fi

# Create the webblocker_blocked table if it doesn't exist
pfctl -t webblocker_blocked -T show 2>/dev/null || pfctl -t webblocker_blocked -T add 0.0.0.0 2>/dev/null || true
pfctl -t webblocker_blocked -T delete 0.0.0.0 2>/dev/null || true

# Flush existing entries
echo "üìã Flushing old blocked IPs..."
pfctl -t webblocker_blocked -T flush 2>/dev/null || true

# Add all blocked IPs to the table
echo "üìã Adding ${validIPs.length} IPs to block list..."
${validIPs.map((ip) => `pfctl -t webblocker_blocked -T add ${escapeShellArg(ip)} 2>/dev/null || true`).join("\n")}

# Load the aggressive rules
echo "üîß Loading aggressive firewall rules..."
pfctl -a "${PF_ANCHOR_NAME}" -f "${PF_RULES_FILE}" 2>/dev/null || true

# CRITICAL: Kill ALL existing connections to blocked IPs
echo "üî™ Terminating ALL existing connections to blocked sites..."

# Method 1: Use pfctl to kill connections by IP
${validIPs.map((ip) => `pfctl -k ${escapeShellArg(ip)} 2>/dev/null || true`).join("\n")}

# Method 2: Kill connections bidirectionally
${validIPs.map((ip) => `pfctl -k 0.0.0.0/0 -k ${escapeShellArg(ip)} 2>/dev/null || true`).join("\n")}

# Method 3: Flush ALL state entries (nuclear option but effective)
echo "üí• Flushing connection state table..."
pfctl -F states 2>/dev/null || true

# Reload PF to ensure rules are active
pfctl -f "${PF_CONF}" 2>/dev/null || true

# Verify rules are loaded
echo "‚úÖ Verifying firewall rules..."
pfctl -a "${PF_ANCHOR_NAME}" -sr 2>/dev/null | head -5

echo ""
echo "‚úÖ AGGRESSIVE PF firewall blocking enabled!"
echo "üìä Blocking ${domains.length} domains at ${validIPs.length} IP addresses"
echo "üî™ All existing connections terminated"
echo "üö´ NO CACHE BYPASS POSSIBLE - Blocking at network layer"
`;

    const tempScriptPath = "/tmp/webblocker_aggressive_enable.sh";
    await fs.writeFile(tempScriptPath, scriptContent);
    await execAsync(`chmod +x ${tempScriptPath}`);

    // Step 5: Execute with authentication
    console.log("üîê Requesting authentication for aggressive blocking...");
    const execResult = await executeScriptWithAuth(
      tempScriptPath,
      "WebBlocker needs to configure aggressive firewall rules to block websites and terminate existing connections",
    );

    if (!execResult.success) {
      await execAsync(`rm -f ${tempScriptPath}`);
      return {
        success: false,
        message: execResult.error || "Authentication failed",
      };
    }

    // Clean up
    await execAsync(`rm -f ${tempScriptPath}`);

    console.log("‚úÖ Aggressive PF blocking enabled successfully!");

    return {
      success: true,
      message: `üî• Aggressive firewall blocking enabled!\nBlocked ${domains.length} domains at ${validIPs.length} IPs\nüî™ All existing connections terminated\nüö´ Network-layer blocking - NO BYPASS POSSIBLE`,
      ipsBlocked: validIPs.length,
    };
  } catch (err) {
    const error = err instanceof Error ? err : new Error(String(err));
    console.error("Aggressive PF blocking error:", error);
    return {
      success: false,
      message: `Failed to enable aggressive PF blocking: ${error.message}`,
    };
  }
}
