/**
 * PF Firewall Manager for WebBlocker
 * Uses macOS Packet Filter (pf) for instant, connection-dropping blocks
 * This is more effective than /etc/hosts as it:
 * - Drops existing connections immediately
 * - Works instantly without DNS cache issues
 * - Blocks at the network layer before any DNS lookup
 */

import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs/promises";
import { executeScriptWithAuth } from "./biometricAuth";
import {
  escapeShellArg,
  isValidIP,
  sanitizeDomainForShell,
} from "./securityUtils";

const execAsync = promisify(exec);

// Constants
const PF_ANCHOR_NAME = "com.webblocker.blocking";
const PF_RULES_FILE = "/tmp/webblocker.pf.rules";
const PF_CONF = "/etc/pf.conf";

export interface FirewallResult {
  success: boolean;
  message: string;
}

/**
 * Extract clean domain from input
 */
function extractDomain(input: string): string {
  let domain = input.toLowerCase().trim();
  domain = domain.replace(/^[a-z]+:\/\//, "");
  domain = domain.split("/")[0];
  domain = domain.split("?")[0];
  domain = domain.split("#")[0];
  domain = domain.split(":")[0];
  return domain;
}

/**
 * Generate PF firewall rules for blocking domains
 */
async function generatePFRules(domains: string[]): Promise<string> {
  // Expand domains to include both www and non-www versions
  const expandedDomains: string[] = [];
  domains.forEach((domain) => {
    const cleanDomain = extractDomain(domain);
    if (!cleanDomain) return;

    expandedDomains.push(cleanDomain);
    if (!cleanDomain.startsWith("www.")) {
      expandedDomains.push(`www.${cleanDomain}`);
    } else {
      expandedDomains.push(cleanDomain.replace(/^www\./, ""));
    }
  });

  const uniqueDomains = Array.from(new Set(expandedDomains));

  // Create PF rules
  // We'll block outgoing connections to these domains
  let rules = `# WebBlocker PF Rules
# Generated by Raycast WebBlocker Extension
# Anchor: ${PF_ANCHOR_NAME}

# Block outgoing connections to blocked domains
`;

  // For each domain, create a block rule
  // PF doesn't support domain names directly, so we'll use a table
  rules += `table <webblocker_blocked> persist\n\n`;

  // Add rules to block connections to IPs in the table
  rules += `block drop out quick from any to <webblocker_blocked>\n`;
  rules += `block drop in quick from <webblocker_blocked> to any\n\n`;

  // Add comment with domains
  rules += `# Blocked domains: ${uniqueDomains.join(", ")}\n`;

  return rules;
}

/**
 * Resolve domains to IP addresses for PF table
 */
async function resolveDomains(domains: string[]): Promise<string[]> {
  const ips: Set<string> = new Set();

  for (const domain of domains) {
    // Sanitize domain before using in shell command
    const sanitizedDomain = sanitizeDomainForShell(domain);
    if (!sanitizedDomain) {
      console.warn(`Skipping invalid domain: ${domain}`);
      continue;
    }

    try {
      // Use dig to resolve domain to IPs - escape domain for shell safety
      const { stdout } = await execAsync(
        `dig +short ${escapeShellArg(sanitizedDomain)} A ${escapeShellArg(sanitizedDomain)} AAAA 2>/dev/null || true`,
      );
      const resolvedIPs = stdout.split("\n").filter((line) => {
        const trimmed = line.trim();
        // Filter valid IPv4 and IPv6 addresses using proper validation
        return trimmed && !trimmed.endsWith(".") && isValidIP(trimmed);
      });

      resolvedIPs.forEach((ip) => ips.add(ip));
    } catch (error) {
      console.error(`Failed to resolve ${domain}:`, error);
    }
  }

  return Array.from(ips);
}

/**
 * Enable PF firewall blocking
 */
export async function enablePFBlocking(
  domains: string[],
): Promise<FirewallResult> {
  if (!domains || domains.length === 0) {
    return {
      success: false,
      message: "No domains provided to block",
    };
  }

  try {
    console.log(
      `üî• Enabling PF firewall blocking for ${domains.length} domains...`,
    );

    // Step 1: Resolve domains to IPs
    console.log("üîç Resolving domains to IP addresses...");
    const expandedDomains: string[] = [];
    domains.forEach((domain) => {
      const cleanDomain = extractDomain(domain);
      if (cleanDomain) {
        expandedDomains.push(cleanDomain);
        if (!cleanDomain.startsWith("www.")) {
          expandedDomains.push(`www.${cleanDomain}`);
        }
      }
    });

    const resolvedIPs = await resolveDomains(expandedDomains);
    console.log(`‚úÖ Resolved ${resolvedIPs.length} IP addresses`);

    // Filter and validate IPs before using in shell commands
    const validIPs = resolvedIPs.filter((ip) => isValidIP(ip));
    console.log(`‚úÖ Validated ${validIPs.length} valid IP addresses`);

    if (validIPs.length === 0) {
      return {
        success: false,
        message: "Could not resolve any valid IPs for the provided domains",
      };
    }

    // Step 2: Generate PF rules
    const rules = await generatePFRules(domains);
    await fs.writeFile(PF_RULES_FILE, rules);

    // Step 3: Create installation script with properly escaped IPs
    const scriptContent = `#!/bin/bash
set +e

echo "üî• Setting up PF firewall blocking..."

# Check if PF anchor already exists in pf.conf
if ! grep -q "${PF_ANCHOR_NAME}" "${PF_CONF}" 2>/dev/null; then
  echo "üìù Adding WebBlocker anchor to pf.conf..."
  echo "" >> "${PF_CONF}"
  echo "# WebBlocker anchor - DO NOT REMOVE" >> "${PF_CONF}"
  echo "anchor \\"${PF_ANCHOR_NAME}\\"" >> "${PF_CONF}"
  echo "load anchor \\"${PF_ANCHOR_NAME}\\" from \\"${PF_RULES_FILE}\\"" >> "${PF_CONF}"
fi

# Populate the webblocker_blocked table with IPs
echo "üìã Populating blocked IPs table..."
pfctl -t webblocker_blocked -T flush 2>/dev/null || true

${validIPs.map((ip) => `pfctl -t webblocker_blocked -T add ${escapeShellArg(ip)} 2>/dev/null || true`).join("\n")}

# Load rules into the anchor
echo "üîß Loading firewall rules..."
pfctl -a "${PF_ANCHOR_NAME}" -f "${PF_RULES_FILE}" 2>/dev/null || true

# Enable PF if not already enabled
if ! pfctl -s info 2>/dev/null | grep -q "Status: Enabled"; then
  echo "üöÄ Enabling PF firewall..."
  pfctl -e 2>/dev/null || true
fi

# Kill existing connections to blocked IPs
echo "üî™ Killing existing connections to blocked sites..."
${validIPs.map((ip) => `pfctl -k ${escapeShellArg(ip)} 2>/dev/null || true`).join("\n")}

# Flush state table to drop existing connections
pfctl -F state 2>/dev/null || true

echo "‚úÖ PF firewall blocking enabled!"
echo "Blocking ${domains.length} domains (${validIPs.length} IPs)"
`;

    const tempScriptPath = "/tmp/webblocker_pf_enable.sh";
    await fs.writeFile(tempScriptPath, scriptContent);
    await execAsync(`chmod +x ${tempScriptPath}`);

    // Step 4: Execute with authentication
    console.log("üîê Requesting authentication...");
    const execResult = await executeScriptWithAuth(
      tempScriptPath,
      "WebBlocker needs to configure firewall rules to block websites",
    );

    if (!execResult.success) {
      await execAsync(`rm -f ${tempScriptPath}`);
      return {
        success: false,
        message: execResult.error || "Authentication failed",
      };
    }

    // Clean up
    await execAsync(`rm -f ${tempScriptPath}`);

    return {
      success: true,
      message: `PF firewall blocking enabled for ${domains.length} domain(s) - blocks are instant!`,
    };
  } catch (err) {
    const error = err instanceof Error ? err : new Error(String(err));
    console.error("PF blocking error:", error);
    return {
      success: false,
      message: `Failed to enable PF blocking: ${error.message}`,
    };
  }
}

/**
 * Disable PF firewall blocking
 */
export async function disablePFBlocking(): Promise<FirewallResult> {
  try {
    console.log("üî• Disabling PF firewall blocking...");

    const scriptContent = `#!/bin/bash
set +e

echo "üî• Removing PF firewall blocking..."

# Flush the anchor rules
pfctl -a "${PF_ANCHOR_NAME}" -F all 2>/dev/null || true

# Clear the blocked IPs table
pfctl -t webblocker_blocked -T flush 2>/dev/null || true
pfctl -t webblocker_blocked -T kill 2>/dev/null || true

# Remove anchor from pf.conf
if grep -q "${PF_ANCHOR_NAME}" "${PF_CONF}" 2>/dev/null; then
  echo "üìù Removing WebBlocker anchor from pf.conf..."
  sed -i.bak "/${PF_ANCHOR_NAME}/d" "${PF_CONF}" 2>/dev/null || true
  sed -i.bak "/# WebBlocker anchor/d" "${PF_CONF}" 2>/dev/null || true
fi

# Clean up rules file
rm -f "${PF_RULES_FILE}" 2>/dev/null || true

# Reload PF configuration
pfctl -f "${PF_CONF}" 2>/dev/null || true

echo "‚úÖ PF firewall blocking disabled!"
`;

    const tempScriptPath = "/tmp/webblocker_pf_disable.sh";
    await fs.writeFile(tempScriptPath, scriptContent);
    await execAsync(`chmod +x ${tempScriptPath}`);

    console.log("üîê Requesting authentication...");
    const execResult = await executeScriptWithAuth(
      tempScriptPath,
      "WebBlocker needs to remove firewall rules to unblock websites",
    );

    if (!execResult.success) {
      await execAsync(`rm -f ${tempScriptPath}`);
      return {
        success: false,
        message: execResult.error || "Authentication failed",
      };
    }

    await execAsync(`rm -f ${tempScriptPath}`);

    return {
      success: true,
      message: "PF firewall blocking disabled - all sites accessible",
    };
  } catch (err) {
    const error = err instanceof Error ? err : new Error(String(err));
    console.error("PF disable error:", error);
    return {
      success: false,
      message: `Failed to disable PF blocking: ${error.message}`,
    };
  }
}

/**
 * Check if PF blocking is currently active
 */
export async function isPFBlockingActive(): Promise<boolean> {
  try {
    const { stdout } = await execAsync(
      `sudo pfctl -a "${PF_ANCHOR_NAME}" -sr 2>/dev/null || echo ""`,
    );
    return stdout.includes("webblocker_blocked");
  } catch {
    return false;
  }
}
