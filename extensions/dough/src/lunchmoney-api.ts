/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/me": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get current user
     * @description Get details about the user associated with the supplied authorization token.
     */
    get: operations["getMe"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/summary": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get summary
     * @description Returns a summary of the budget activity for the specified date range.
     */
    get: operations["getBudgetSummary"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/categories": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all categories
     * @description Retrieve a list of all categories associated with the user's account.
     */
    get: operations["getAllCategories"];
    put?: never;
    /**
     * Create a new category or category group
     * @description Creates a new category with the given name.<br> If the `is_group` attribute is set to true, a category group is created. In this case, the `children` attribute may be set to an array of existing category IDs to add to the newly-created category group.
     */
    post: operations["createCategory"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/categories/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single category
     * @description Retrieve details of a specific category or category group by its ID.
     */
    get: operations["getCategoryById"];
    /**
     * Update an existing category or category group
     * @description Modifies the properties of an existing category or category group.<br><br>
     *     You may submit the response from a `GET /categories/{id}` as the request body; however, only certain properties can be updated using this API. The following properties are accepted in the request body but their values will be ignored: `id`, `is_group`,`archived_at`, `updated_at`, `created_at`, and `order`.<br><br>
     *     It is also possible to provide only the properties to be updated in the request body, as long as the request includes at least one of the properties that is not listed above. For example, a request body that contains only a `name` property is valid.<br><br>
     *     It is not possible to use this API to convert a category to a category group, or a vice versa, so while submitting a request body with the `is_group` property is tolerated, it will result in an error response if the value is changed.<br><br>
     *     It is possible to modify the children of an existing category group with this API by setting the `children` attribute. If this is set, it will replace the existing children with the newly specified children. If the intention is to add or remove a single category, it is more straightforward to update the child category by specifying the new `group_id` attribute. If the goal is to add multiple new children or remove multiple existing children, it is recommended to first call the `GET /categories/:id` endpoint to get the existing children and then modify the list as desired.<br><br>
     */
    put: operations["updateCategory"];
    post?: never;
    /**
     * Delete a category or category group
     * @description Attempts to delete the single category or category group specified on the path. By default, this will only work if there are no dependencies, such as existing budgets for the category, categorized transactions, children categories for a category group, categorized recurring items, etc. If there are dependents, this endpoint will return an object that describes the amount and type of existing dependencies.
     */
    delete: operations["deleteCategory"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/manual_accounts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all manual accounts
     * @description Retrieve a list of all manually-managed accounts associated with the user's account.
     */
    get: operations["getAllManualAccounts"];
    put?: never;
    /**
     * Create a manual account
     * @description Create a new manually-managed account.<br><br>
     */
    post: operations["createManualAccount"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/manual_accounts/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single manual account
     * @description Retrieve the details of the manual account with the specified ID.
     */
    get: operations["getManualAccountById"];
    /**
     * Update an existing manual account
     * @description Modifies the properties of an existing manual account.<br><br>
     *     You may submit the response from a `GET /manual_accounts/{id}` as the request body, however only certain properties can be updated using this API. The following system set properties are accepted in the request body but their values will be ignored: `id`, `created_at`, and `updated_at`.<br><br>
     *     It is also possible to provide only the properties to be updated in the request body, as long as the request includes at least one of the properties that is not listed above. For example a request body that contains only a `name` property is valid.<br><br>
     */
    put: operations["updateManualAccount"];
    post?: never;
    /**
     * Delete a manual account
     * @description Deletes the single manual account with the ID specified on the path. If any transactions exist with the `manual_account_id` property set to this account's ID they will appear with a warning when displayed in the web view.
     */
    delete: operations["deleteManualAccount"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/plaid_accounts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all accounts synced via Plaid
     * @description Retrieve a list of all synced accounts associated with the user's account.
     */
    get: operations["getAllPlaidAccounts"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/plaid_accounts/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single account that is synced via Plaid
     * @description Retrieve the details of the plaid account with the specified ID.
     */
    get: operations["getPlaidAccountById"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/plaid_accounts/fetch": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Trigger Fetch from Plaid
     * @description Use this endpoint to trigger a fetch for latest data from Plaid.<br><br>
     *     Eligible accounts are those who last_fetch value is over 1 minute ago. (Although the limit is every minute, please use this endpoint sparingly!) Successive calls to this endpoint under a minute after the first will return a 425 TOO EARLY response.<br><br>
     *     Successful calls will return a 202 ACCEPTED response. Note that fetching from Plaid is a background job. This endpoint simply queues up the job. You may track the `plaid_last_successful_update`, `last_fetch` and `last_import` properties to verify the results of the fetch. The `last fetch` property is updated when Plaid accepts a request to fetch data. The `plaid_last_successful_update`is updated when it successfully contacts the associated financial institution. The `last_import` field is updated only when new transactions have been imported.
     */
    post: operations["triggerPlaidAccountFetch"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all transactions
     * @description Retrieve a list of all transactions associated with a user's account. <br>If called with no parameters, this endpoint will return the most recent transactions up to `limit` number of transactions.
     */
    get: operations["getAllTransactions"];
    /**
     * Update multiple transactions
     * @description Modifies the properties of multiple existing transactions in a single request.<br><br>
     *     You may submit complete transaction objects from the response returned by a `GET /transactions` in the request body for each transaction, however only certain properties can be updated using this API. The following system set properties are accepted in the request body, but their values will be ignored: `id`, `to_base`, `is_pending`, `created_at`, `updated_at`, `source`, and `plaid_metadata`.<br><br>
     *     Transactions that have been previously split or grouped may not be modified by this endpoint. Therefore the `is_parent`, `parent_id`, `is_group`, `group_id`, and `children` properties are also ignored when provided in the request body.<br><br>
     *     Each transaction in the array **must** include an `id` property to identify which transaction to update, along with at least one other property to be updated. For example, a transaction object that contains only an `id` and `category_id` property is valid.<br><br>
     *     The request can include between 1 and 500 transactions to update in a single call.
     */
    put: operations["updateTransactions"];
    /**
     * Insert one or more transactions.
     * @description Use this endpoint to add transactions to a budget.
     *
     *     The request body for this endpoint must include a list of transactions with at least one transaction and not more than 500 transactions to insert.
     *
     *     The successful request to this endpoint will return a response body which will include two arrays: <br>  - `transactions`: A list of transactions that were successfully inserted.<br> - `skipped_duplicates`: A list of transactions that were duplicates of existing transactions and were not inserted.
     */
    post: operations["createNewTransactions"];
    /**
     * Bulk delete existing transactions
     * @description Deletes the transaction with the IDs specified in the request body.<br>
     *     If any of the specified transactions are a split transaction or a split parent, or if any are a grouped transactions or part of a transaction group, the request will fail with a suggestion on how to unsplit or ungroup the transaction(s) prior to deletion. This will also fail if any of the specified transaction IDs do not exist.<br>
     *     Otherwise, the specified transactions are deleted.<br><br>
     *     **Use with caution. This action is not reversible!**
     */
    delete: operations["deleteTransactions"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single transaction
     * @description Retrieves the details of a specific transaction by its ID, including the following properties which are not returned by default in the response to a `GET /transactions` request:<br>
     *
     *     - `plaid_metadata` will either be `null` or contain the metadata for transactions associated with an account that is synced via plaid.
     *     - `custom_metadata` will either be `null` or contain any custom_metadata added to transactions that were inserted or updated via the API.
     *     - `files` will be a list of objects that describe any attachments to the transaction.
     *
     *     If `is_group` is true in the returned transaction, the object will also include the `children` property which will contain a list of the  original transactions that make up the transaction group.<br>
     *     If `is_parent` is true in the returned transaction, the object will also include the `children` property which will contain a list of the split transactions.
     */
    get: operations["getTransactionById"];
    /**
     * Update an existing transaction
     * @description Modifies the properties of an existing transaction.<br><br>
     *     You may submit the response from a `GET /transactions/{id}` as the request body, however only certain properties can be updated using this API. The following system set properties are accepted in the request body but their values will be ignored: `id`, `to_base`, `is_pending`, `created_at`, `updated_at`, `source`, and `plaid_metadata`.<br><br>
     *     Transactions that have been previously split or grouped may not be modified by this endpoint. Therefore the `is_parent`, `parent_id`, `is_group`, `group_id`, and `children` properties are also ignored when provided in the request body.<br><br>
     *     It is also possible to provide only the properties to be updated in the request body, as long as the request includes at least one of the properties that is not listed above. For example a request body that contains only an `category_id` attribute is valid.
     */
    put: operations["updateTransaction"];
    post?: never;
    /**
     * Delete a transaction
     * @description Deletes the transaction with the ID specified on the path.<br>
     *     If the specified transaction is a split transaction or a split parent, or if it is a grouped transactions or part of a transaction group, the request will fail with a suggestion on how to unsplit or ungroup the transaction(s) prior to deletion. Otherwise, the specified transaction is deleted. <br>
     *     This action is not reversible!
     */
    delete: operations["deleteTransactionById"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/group": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a transaction group
     * @description Specify a set of existing transaction IDs to group together as a single grouped transaction.
     *     The new transaction will have an amount equal to the sum of the grouped transaction amounts. If the
     *     grouped transactions have different currencies, the new group transaction will be set in the user's
     *     default currency.<br><br>
     *     After a transaction has been grouped, the original transactions are no longer shown on the
     *     transactions page or returned by a `GET /transactions` request. The newly created grouped
     *     transaction is returned instead.
     *
     *     To see the details of the original transactions that were used to create a transaction group, use the
     *     `GET /transactions/{id}` endpoint and pass the ID of the grouped transaction. The grouped transactions will
     *     be included in the `children` property of the transaction returned in the response
     */
    post: operations["groupTransactions"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/group/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a transaction group
     * @description Deletes the transaction group with the ID specified on the path.<br>
     *     The transactions within the group are not removed and will subsequently be treated as "normal" ungrouped transactions.
     */
    delete: operations["ungroupTransactions"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/split/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Split a transaction
     * @description Splits an existing transaction into a set of smaller child transactions.<br><br> After a transaction has been split, the original transaction is no longer shown on the transactions page or returned by a `GET /transactions` request. The newly created child transactions are returned instead.
     *     To see the details of the original parent transaction after it has been split, use the `GET /transactions/{id}` endpoint and pass the value of the `parent_id` of one of the children.
     */
    post: operations["splitTransaction"];
    /**
     * Unsplit a previously split transactions
     * @description Deletes the split children of a previously split transactions and restores the parent transactions to the normal unsplit state.<br><br>
     *     Use the value of the `parent_id`property of a split transaction to specify the parent ID.
     */
    delete: operations["unsplitTransaction"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/{transaction_id}/attachments": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Attach a file to a transaction
     * @description Attaches a file to a transaction. The file must be less than 10MB in size.<br><br> The file will be attached to the transaction and can be downloaded from the link returned by a `GET /transactions/attachments/{file_id}` request.
     */
    post: operations["attachFileToTransaction"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/attachments/{file_id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a url to download a file attachment
     * @description Returns a signed url that can be used to download the file attachment.
     */
    get: operations["getTransactionAttachmentUrl"];
    put?: never;
    post?: never;
    /**
     * Delete a file attachment
     * @description Deletes a file attachment from a transaction.
     */
    delete: operations["deleteTransactionAttachment"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tags": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get All Tags
     * @description Retrieve a list of all tags associated with the user's account.
     */
    get: operations["getAllTags"];
    put?: never;
    /**
     * Create a new tag
     * @description Creates a new tag with the given name
     */
    post: operations["createTag"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/tags/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single tag
     * @description Retrieve the details of a specific tag with the specified ID.
     */
    get: operations["getTagById"];
    /**
     * Update an existing tag
     * @description Updates an existing tag.<br><br>
     *     You may submit the response from a `GET /tags/{id}` as the request body, however only certain properties can be updated using this API. The following system set properties are accepted in the request body but their values will be ignored: `id`, `updated_at`, `created_at`, and `archived_at`.<br><br>
     *     It is also possible to provide only the properties to be updated in the request body, as long as the request includes at least one of the properties that is not listed above. For example a request body that contains only a `name` attribute is valid.
     */
    put: operations["updateTag"];
    post?: never;
    /**
     * Delete a tag
     * @description Deletes the tag with the ID specified on the path.<br>
     *     If transaction or rules exist with the tag a dependents object is returned and the tag is not deleted. This behavior can be overridden by setting the `force` param to `true`.
     */
    delete: operations["deleteTag"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/recurring_items": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all recurring items
     * @description Get info about the recurring items for a specified time frame
     */
    get: operations["getAllRecurring"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/recurring_items/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single recurring item
     * @description Retrieve the details of a specific recurring item with the specified ID.
     */
    get: operations["getRecurringById"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    userObject: {
      /** @description User's name */
      name: string;
      /** @description User's email */
      email: string;
      /**
       * Format: int32
       * @description Unique identifier for user
       */
      id: number;
      /**
       * Format: int64
       * @description Unique identifier for the associated budgeting account
       */
      account_id: number;
      /** @description Name of the associated budgeting account */
      budget_name: string;
      /** @description Primary currency from user's settings */
      primary_currency: components["schemas"]["currencyEnum"];
      /** @description User-defined label of the developer API key used. Returns null if nothing has been set. */
      api_key_label: string | null;
    };
    /** category object */
    categoryObject: {
      /**
       * Format: int32
       * @description A system defined unique identifier for the category.
       */
      id: number;
      /** @description The name of the category. */
      name: string;
      /** @description The description of the category or `null` if not set. */
      description: string | null;
      /** @description If `true`, the transactions in this category will be treated as income. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details) */
      is_income: boolean;
      /** @description If `true`, the transactions in this category will be excluded from the budget. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details) */
      exclude_from_budget: boolean;
      /** @description If `true`, the transactions in this category will be excluded from totals. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details) */
      exclude_from_totals: boolean;
      /**
       * Format: date-time
       * @description The date and time of when the category was last updated (in the ISO 8601 extended format).
       */
      updated_at: string;
      /**
       * Format: date-time
       * @description The date and time of when the category was created (in the ISO 8601 extended format).
       */
      created_at: string;
      /**
       * Format: int64
       * @description The ID of the category group this category belongs to or `null` if the category doesn't belong to a group, or is itself a category group.
       */
      group_id: number | null;
      /** @description If `true`, the category is created as a category group. */
      is_group: boolean;
      /** @description For category groups, this will populate with details about the categories that belong to this group. The objects in this array are similar to Category Objects but do not include the `is_income`, `exclude_from_budget`, and `exclude_from_totals` properties as these are inherited from the category group. In addition, the `is_group` property will always be `false`, and there will be no `children` attribute. */
      children?: components["schemas"]["childCategoryObject"][];
      /** @description If true, the category is archived and not displayed in relevant areas of the Lunch Money app. */
      archived: boolean;
      /**
       * Format: date-time
       * @description The date and time of when the category was last archived (in the ISO 8601 extended format).
       */
      archived_at: string | null;
      /**
       * @description An integer specifying the position in which the category is displayed on the categories page in the Lunch Money GUI. For categories within a category group the order is relative to the other categories within the group.<br>Categories with `order: null` will be displayed in alphabetical order by name, prior to any categories with an order
       * @default null
       */
      order: number | null;
      /**
       * @description If `true`, the category is collapsed in the Lunch Money GUI.
       * @default false
       */
      collapsed: boolean;
    };
    childCategoryObject: {
      /**
       * Format: int32
       * @description A system defined unique identifier for the category.
       */
      id: number;
      /** @description The name of the category. */
      name: string;
      /** @description The description of the category or `null` if not set. */
      description: string | null;
      /** @description If true, the transactions in this category will be treated as income. Inherited from Category Group. */
      is_income: boolean;
      /** @description If true, the transactions in this category will be excluded from the budget. Inherited from Category Group. */
      exclude_from_budget: boolean;
      /** @description If true, the transactions in this category will be excluded from totals. Inherited from Category Group. */
      exclude_from_totals: boolean;
      /**
       * Format: date-time
       * @description The date and time of when the category was last updated (in the ISO 8601 extended format).
       */
      updated_at: string;
      /**
       * Format: date-time
       * @description The date and time of when the category was created (in the ISO 8601 extended format).
       */
      created_at: string;
      /**
       * Format: int64
       * @description The ID of the category group this category belongs to or `null` if the category doesn't belong to a group, or is itself a category group.
       */
      group_id: number | null;
      /**
       * @description Will always be false for a category that is part of category group.
       * @enum {boolean}
       */
      is_group: false;
      /** @description If true, the category is archived and not displayed in relevant areas of the Lunch Money app. */
      archived: boolean;
      /**
       * Format: date-time
       * @description The date and time of when the category was last archived (in the ISO 8601 extended format).
       */
      archived_at: string | null;
      /** @description An index specifying the position in which the category is displayed on the categories page in the Lunch Money GUI. For categories within a category group the order is relative to the other categories within the group.<br> API. */
      order: number | null;
      /** @description If `true`, the category is collapsed in the Lunch Money GUI. */
      collapsed?: boolean | null;
    };
    createCategoryRequestObject: {
      /**
       * @description The name of the new category. Must be between 1 and 100 characters.
       *     Must not match the name of any existing categories or category groups.
       */
      name: string;
      /**
       * @description The description of the category. Must not exceed 200 characters.
       * @default null
       */
      description: string | null;
      /**
       * @description If `true`, the transactions in this category will be treated as income. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details)
       * @default false
       */
      is_income: boolean;
      /**
       * @description If `true`, the transactions in this category will be excluded from the budget. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details)
       * @default false
       */
      exclude_from_budget: boolean;
      /**
       * @description If `true`, the transactions in this category will be excluded from totals. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details)
       * @default false
       */
      exclude_from_totals: boolean;
      /**
       * @description If `true`, the category is created as a category group.
       * @default false
       */
      is_group: boolean;
      /**
       * Format: int64
       * @description If set to the ID of an existing category group, this new category will be assigned to that group. Cannot be set if `is_group` is true.
       * @default null
       */
      group_id: number | null;
      /**
       * @description If `true`, the category is archived and not displayed in relevant areas of the Lunch Money app.
       * @default false
       */
      archived: boolean;
      /** @description The list of existing category objects, or existing category IDs or names of new categories to add to the new category group. This attribute should only be set if `is_group` is also set to true.<br> The categories or IDs specified must already exist and may not be category groups themselves. Categories that already belong to another category group will be moved. If strings are specified, they will be used as the names of new categories that will be added to the new category group. The request will fail if any names are the same as the name of an existing category.<br> It is permissible to provide both full category objects and IDs as well as strings for names in the same request. */
      children?: (number | string | components["schemas"]["categoryObject"])[];
      /** @description An index specifying the position in which the category is displayed on the categories page in the Lunch Money GUI. For categories within a category group the order is relative to the other categories within the group.<br>While this property can be set via the API it is generally set by the user in the Lunch Money GUI. API. */
      order?: number | null;
      /** @description If `true`, the category is collapsed in the Lunch Money GUI.<br>While this property can be set via the API it is generally set by the user in the Lunch Money GUI. */
      collapsed?: boolean | null;
    };
    updateCategoryRequestObject: {
      /** @description If set, the new name of the category. Must be between 1 and 100 characters. */
      name?: string;
      /** @description If set, the new description of the category. Must not exceed 200 characters. */
      description?: string | null;
      /** @description If set, will indicate if this category will be treated as income. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details) */
      is_income?: boolean;
      /** @description If set, will indicate if this category will be excluded from budgets. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details) */
      exclude_from_budget?: boolean;
      /** @description If set, will indicate if this category will be excluded from totals. (See <a href="https://support.lunchmoney.app/setup/categories/category-properties">Category Properties</a> for more details) */
      exclude_from_totals?: boolean;
      /** @description If set, will indicate if this category is archived. */
      archived?: boolean;
      /**
       * Format: int64
       * @description If set to the ID of an existing category group, and this category is not itself a category group, this category will be a child of the specified group.
       */
      group_id?: number | null;
      /**
       * @description This attribute may not be set to a value that is different than the current status of the category or category group. In other words, this API may not be used to convert a category to a category group or vice versa.
       * @default false
       */
      is_group: boolean | null;
      /** @description The list of existing category objects, or existing category IDs or names of new categories to add to the new category group. This attribute should only be set if modifying an existing category group.<br> The categories or IDs specified must already exist and not belong to an existing category group. Categories that already belong to another category group will be moved. If strings are specified, they will be used as the names of new categories that will be added to the new category group. The request will fail if any names are the same as the name of an existing category.<br> It is permissible to provide both full category objects and IDs as well as strings for names in the same request. */
      children?: (number | string | components["schemas"]["categoryObject"])[];
      /** @description An index specifying the position in which the category is displayed on the categories page in the Lunch Money GUI. For categories within a category group the order is relative to the other categories within the group.<br>While this property can be set via the API it is generally set by the user in the Lunch Money GUI. API. */
      order?: number | null;
      /** @description If `true`, the category is collapsed in the Lunch Money GUI.<br>While this property can be set via the API it is generally set by the user in the Lunch Money GUI. */
      collapsed?: boolean | null;
      /**
       * Format: int64
       * @description System defined unique identifier for the category. Ignored if set.
       */
      id?: number;
      /** @description System set date and time of when the category was last archived (in the ISO 8601 extended format). Ignored if set. */
      archived_at?: string | null;
      /**
       * Format: date-time
       * @description System set date and time of when the category was last updated (in the ISO 8601 extended format). Ignored if set.
       */
      updated_at?: string;
      /**
       * Format: date-time
       * @description System set date and time of when the category was created (in the ISO 8601 extended format). Ignored if set. (in the ISO 8601 extended format). Ignored if set.
       */
      created_at?: string;
    };
    deleteCategoryResponseWithDependencies: {
      /** @description The name of the category */
      category_name: string;
      dependents: {
        /** @description The number of budgets depending on the category */
        budget: number;
        /** @description The number of category rules depending on the category */
        category_rules: number;
        /** @description The number of transactions depending on the category */
        transactions: number;
        /** @description The number of child categories in the category group */
        children: number;
        /** @description The number of recurring transactions depending on the category */
        recurring: number;
        /** @description The number of auto created categories based on Plaid categories */
        plaid_cats: number;
      };
    };
    transactionObject: {
      /**
       * Format: int64
       * @description System created unique identifier for transaction
       */
      id: number;
      /**
       * Format: date
       * @description Date of transaction in ISO 8601 format
       */
      date: string;
      /** @description Amount of the transaction in numeric format to 4 decimal places. Positive values indicate a debit transaction, negative values indicate a credit transaction. */
      amount: string;
      /** @description Three-letter lowercase currency code of the transaction in ISO 4217 format. */
      currency: components["schemas"]["currencyEnum"];
      /**
       * Format: double
       * @description The amount converted to the user's primary currency. If the multi-currency feature is not being used, to_base and amount will be the same. Positive values indicate a debit transaction, negative values indicate a credit transaction.
       */
      to_base: number;
      /**
       * Format: int32
       * @description The unique identifier of the associated recurring item that this transaction matched.
       */
      recurring_id: number | null;
      /**
       * @description Name of payee set by the user, the financial institution, or by
       *     a matched recurring item. This will match the value
       *     displayed in payee field on the transactions page in the GUI.
       */
      payee: string;
      /**
       * Format: int32
       * @description Unique identifier of associated category set by the user or by a matched recurring_item.<br> Category details can be obtained by passing the value of this property to the [Get A Single Category](../operations/getCategoryById) API
       */
      category_id: number | null;
      /**
       * Format: int32
       * @description The unique identifier of the plaid account associated with this transaction. This will always be null if this transaction is associated with a manual account or if this transaction has no associated account and appears as a "Cash Transaction" in the Lunch Money GUI.
       */
      plaid_account_id: number | null;
      /**
       * Format: int32
       * @description The unique identifier of the manual account associated with this transaction. This will always be null if this transaction is associated with a synced account or if this transaction has no associated account and appears as a "Cash Transaction" in the Lunch Money GUI.
       */
      manual_account_id: number | null;
      /** @description A user-defined external ID for any transaction that was added via csv import, `POST /transactions` API call, or manually added via the Lunch Money GUI. No external ID exists for transactions associated with synced accounts, and they cannot be added. For transactions associated with manual accounts, the external ID must be unique as attempts to add a subsequent transaction with the same external_id and manual_account_id will be flagged as duplicates and fail. */
      external_id: string | null;
      /** @description A list of tag_ids for the tags associated with this transaction. If the transaction has no tags this will be an empty list.<br> Tag details can be obtained by passing the value of this attribute as the `ids` query parameter to the [List Tags](../operations/getTags) API */
      tag_ids: number[];
      /**
       * @description Any transaction notes set by the user or by
       *     a matched recurring item. This will match the value
       *     displayed in notes field on the transactions page in the GUI.
       */
      notes: string | null;
      /**
       * @description Status of the transaction:
       *     - `reviewed`: User has reviewed the transaction, or it was automatically marked as reviewed due to reviewed recurring_item logic
       *     - `unreviewed`: User has not reviewed the transaction and it does not match any reviewed recurring_items. Note that any transactions  where `is_pending` is true will be returned with a status of unreviewed.
       *     - `delete_pending`: The synced account deleted this transaction after it was updated by the user. Requires manual intervention.
       * @enum {string}
       */
      status: "reviewed" | "unreviewed" | "delete_pending";
      /** @description Denotes if the transaction is pending (not posted). Applies only to transactions in synced accounts and will always be false for transactions associated with manual accounts. */
      is_pending: boolean;
      /**
       * Format: date-time
       * @description The date and time of when the transaction was created (in the ISO 8601 extended format).
       */
      created_at: string;
      /**
       * Format: date-time
       * @description The date and time of when the transaction was last updated (in the ISO 8601 extended format).
       */
      updated_at: string;
      /** @description If `true`, this transaction has been split into two or more other transactions. By default, parent transactions are not returned in call to `GET /transactions` but they can be queried directly by their ID. */
      is_parent?: boolean;
      /**
       * Format: int64
       * @description A transaction ID if this is a split transaction. Denotes the transaction ID of the original, or parent, transaction. Is null if this is not a split transaction
       */
      parent_id: number | null;
      /** @description `true` if this transaction represents a group of transactions. If so, amount and currency represent the totalled amount of transactions bearing this transaction's id as their group_id. Amount is calculated based on the user's primary currency. */
      is_group: boolean;
      /**
       * Format: int64
       * @description Is set if this transaction is part of a group. Denotes the ID of the grouped transaction this is now included in. By default the transactions that were grouped are not returned in a call to `GET /transactions` but they can be queried directly by calling the `GET /transactions/group/{id}`, where the id passed is associated with a transaction where the `is_group` attribute is true
       */
      group_id: number | null;
      /** @description Exists only for transactions which are the parent of a split transaction or for transaction groups. It will not exist in the response unless the `include_children` query parameter is set to `true`.<br> For parents of split transactions, it contains a list of the associated transactions that it was split into. For transaction groups, it contains the transactions that were grouped together. Examine the `is_parent` and `is_group` properties to determine which of these it is. */
      children?: components["schemas"]["childTransactionObject"][];
      /** @description If requested, the transaction's plaid_metadata that came when this transaction was obtained. This will be a json object, but the schema is variable. This is only present when the `include_metadata` query parameter is set to true. */
      plaid_metadata?: Record<string, never> | null;
      /** @description If requested, the transaction's custom_metadata that was included when the transaction was inserted via the API. This will be a json object, but the schema is variable. This is only present when the `include_metadata` query parameter is set to true. */
      custom_metadata?: Record<string, never> | null;
      /** @description A list of objects that describe any attachments to the Transactions. This is only present when the `include_files` query parameter is set to true. */
      files?: components["schemas"]["transactionAttachmentObject"][];
      /**
       * @description Source of the transaction:
       *     - `api`: Transaction was added by a call to the [POST /transactions](../operations/createTransaction) API
       *     - `csv`: Transaction was added via a CSV Import
       *     - `manual`: Transaction was created via the "Add to Cash" button on the Transactions page
       *     - `merge`: Transactions were originally in an account that was merged into another account
       *     - `plaid`: Transaction came from a Financial Institution synced via Plaid
       *     - `recurring`: Transaction was created from the Recurring page
       *     - `rule`: Transaction was created by a rule to split a transaction
       *     - `split`: Transaction was created by splitting another transaction
       *     - `user`: This is a legacy value and is replaced by either csv or manual
       * @enum {string|null}
       */
      source:
        | "api"
        | "csv"
        | "manual"
        | "merge"
        | "plaid"
        | "recurring"
        | "rule"
        | "split"
        | "user"
        | null;
    };
    childTransactionObject: {
      /**
       * Format: int64
       * @description System created unique identifier for transaction
       */
      id: number;
      /**
       * Format: date
       * @description Date of transaction in ISO 8601 format
       */
      date: string;
      /** @description Amount of the transaction in numeric format to 4 decimal places. Positive values indicate a debit transaction, negative values indicate a credit transaction. */
      amount: string;
      /** @description Three-letter lowercase currency code of the transaction in ISO 4217 format */
      currency: components["schemas"]["currencyEnum"];
      /**
       * Format: double
       * @description The amount converted to the user's primary currency. If the transaction currency is the same as the user's primary currency, to_base and amount will be the same. Positive values indicate a debit transaction, negative values indicate a credit transaction.
       */
      to_base: number;
      /**
       * Format: int32
       * @description The unique identifier of the associated recurring item that this transaction matched.
       */
      recurring_id: number | null;
      /**
       * @description Name of payee set by the user, the financial institution, or by
       *     a matched recurring item. This will match the value
       *     displayed in payee field on the transactions page in the GUI.
       */
      payee: string;
      /**
       * Format: int32
       * @description Unique identifier of associated category set by the user or by a matched recurring item.<br> Category details can be obtained by passing the value of this property to the [Get A Single Category](../operations/getCategoryById) API
       */
      category_id: number | null;
      /**
       * @description Any transaction notes set by the user or by
       *     a matched recurring item. This will match the value
       *     displayed in notes field on the transactions page in the GUI.
       */
      notes: string | null;
      /**
       * @description Status of the transaction.  Will be one of the following values:
       * @enum {string}
       */
      status: "reviewed" | "unreviewed" | "delete_pending";
      /** @description Denotes if the transaction is pending (not posted). Applies only to transactions in synced accounts and will always be false for transactions associated with manual accounts. */
      is_pending: boolean;
      /**
       * Format: date-time
       * @description The date and time of when the transaction was created (in the ISO 8601 extended format).
       */
      created_at: string;
      /**
       * Format: date-time
       * @description The date and time of when the transaction was last updated (in the ISO 8601 extended format).
       */
      updated_at: string;
      /** @description If true this transaction has been split into two or more other transactions. By default parent transactions are not returned in call to `GET /transactions` but they can be queried directly by their ID. */
      is_parent?: boolean;
      /**
       * Format: int64
       * @description A transaction ID if this is a split transaction. Denotes the transaction ID of the original, or parent, transaction. Is null if this is not a split transaction
       */
      parent_id: number | null;
      /** @description True if this transaction represents a group of transactions. If so, amount and currency represent the totalled amount of transactions bearing this transaction's id as their group_id. Amount is calculated based on the user's primary currency. */
      is_group: boolean;
      /**
       * Format: int64
       * @description Is set if this transaction is part of a group. Denotes the ID of the grouped transaction this is now included in. By default the transactions that were grouped are not returned in a call to `GET /transactions` but they can be queried directly by calling the `GET /transactions/group/{id}`, where the id passed is associated with a transaction where the `is_group` attribute is true
       */
      group_id: number | null;
      /**
       * Format: int32
       * @description The unique identifier of the manual account associated with this transaction. This will always be null if this transaction is associated with a synced account or if this transaction has no associated account and appears as a "Cash Transaction" in the Lunch Money GUI.
       */
      manual_account_id: number | null;
      /**
       * Format: int32
       * @description The unique identifier of the plaid account associated with this transaction. This will always be null if this transaction is associated with a manual account or if this transaction has no associated account and appears as a "Cash Transaction" in the Lunch Money GUI.
       */
      plaid_account_id: number | null;
      /** @description A list of tag_ids for the tags associated with this transaction. If the transaction has no tags this will be an empty list.<br> Tag details can be obtained by passing the value of this attribute as the `ids` query parameter to the [List Tags](../operations/getTags) API */
      tag_ids: number[];
      /**
       * @description Source of the transaction:
       *     - `api`: Transaction was added by a call to the [POST /transactions](../operations/createTransaction) API
       *     - `csv`: Transaction was added via a CSV Import
       *     - `manual`: Transaction was created via the "Add to Cash" button on the Transactions page
       *     - `merge`: Transactions were originally in an account that was merged into another account
       *     - `plaid`: Transaction came from a Financial Institution synced via Plaid
       *     - `recurring`: Transaction was created from the Recurring page
       *     - `rule`: Transaction was created by a rule to split a transaction
       *     - `split`: This is a transaction created by splitting another transaction
       *     - `user`: This is a legacy value and is replaced by either csv or manual
       * @enum {string|null}
       */
      source:
        | "api"
        | "csv"
        | "manual"
        | "merge"
        | "plaid"
        | "recurring"
        | "rule"
        | "split"
        | "user"
        | null;
      /** @description A user-defined external ID for any transaction that was added via csv import, `POST /transactions` API call, or manually added via the Lunch Money GUI. No external ID exists for transactions associated with synced accounts, and they cannot be added. For transactions associated with manual accounts, the external ID must be unique as attempts to add a subsequent transaction with the same external_id and manual_account_id will be flagged as duplicates and fail. */
      external_id: string | null;
      /** @description If requested, the transaction's plaid_metadata that came when this transaction was obtained. This will be a json object, but the schema is variable. This will only be present for transactions associated with a plaid account. */
      plaid_metadata?: Record<string, never> | null;
      /** @description If requested, the transaction's custom_metadata that was included when the transaction was inserted via the API. This will be a json object, but the schema is variable. */
      custom_metadata?: Record<string, never> | null;
      /** @description A list of objects that describe any attachments to the transaction */
      files?: components["schemas"]["transactionAttachmentObject"][];
    };
    insertTransactionObject: {
      /**
       * Format: date
       * @description Date of transaction in ISO 8601 format
       */
      date: string;
      /** @description Numeric value of amount without currency symbol. i.e. $4.25 should be denoted as 4.25. May be a string or a number in double format. Positive values indicate a debit transaction, negative values indicate a credit transaction. */
      amount: number | string;
      /** @description Three-letter lowercase currency code of the transaction in ISO 4217 format. Must match one of the [supported currencies](). If not set defaults to the user account's primary currency. */
      currency?: components["schemas"]["currencyEnum"];
      /** @description Name of payee for the transaction. */
      payee?: string;
      /**
       * Format: int32
       * @description The ID of the category associated with the transactions. If set, the category ID must exist for the user's account and it cannot be a category group.
       */
      category_id?: number | null;
      /**
       * @description Any transaction notes set by the user or by
       *     a matched recurring item. This will match the value
       *     displayed in notes field on the transactions page in the GUI.
       */
      notes?: string | null;
      /**
       * Format: int32
       * @description The Unique identifier for the associated manually managed account. If set, this must match an existing manual account id associated with the user's account. If not set, and `plaid_account_id` is also not set, no account is associated with the transaction and it will appear as a "Cash Transaction" in the Lunch Money GUI. It is an error if this, and `plaid_account_id` is also set on the same transaction.
       */
      manual_account_id?: number | null;
      /**
       * Format: int32
       * @description The Unique identifier for the associated plaid synced account. If set, this must match an existing plaid account id associated with the user's account. If not set, and `manual_account_id` is also not set, no account is associated with the transaction and it will appear as a "Cash Transaction" in the Lunch Money GUI. It is an error if this, and `manual_account_id` is also set on the same transaction. In addition the specified plaid account must have the "Allow Modifications To Transactions" property set (which is enabled by default), or the insert will fail.
       */
      plaid_account_id?: number | null;
      /**
       * Format: int32
       * @description Unique identifier for associated recurring item. Recurring item must be associated with the same account.
       */
      recurring_id?: number | null;
      /**
       * @description If set must be either `reviewed` or `unreviewed`. If not set, defaults to `unreviewed`.
       * @enum {string}
       */
      status?: "reviewed" | "unreviewed";
      /** @description A list of IDs for the tags associated with this transaction. Each ID must match an existing tag associated with the user's account. If not set, no tags will be associated with the created transaction. */
      tag_ids?: number[];
      /** @description A user-defined external ID for the transaction. If set, and `manual_account_id` is set, the creation of the new transaction will fail if a transaction with this id already exists for the specified manual account. */
      external_id?: string | null;
      /** @description An optional JSON object that includes additional data related to this transaction. This must be a valid JSON object and, when stringified, must not exceed 4096 characters. This data may be available in the future for processing by rules. */
      custom_metadata?: {
        [key: string]: unknown;
      } | null;
    };
    updateTransactionObject: {
      /**
       * Format: int64
       * @description System defined unique identifier of this transaction. Ignored if set.
       */
      id?: number;
      /**
       * Format: date
       * @description Date of transaction in ISO 8601 format
       */
      date?: string;
      /** @description Numeric value of amount without currency symbol. i.e. $4.25 should be denoted as 4.25. May be a string or a number in double format. Positive values indicate a debit transaction, negative values indicate a credit transaction. <br> May not be updated on transactions that belong to a synced account with the "Allow Modifications to Transactions" property disabled. */
      amount?: number | string;
      /** @description Three-letter lowercase currency code of the transaction in ISO 4217 format.<br> May not be updated on transactions that belong to a synced account with the "Allow Modifications to Transactions" property disabled. */
      currency?: components["schemas"]["currencyEnum"];
      /**
       * Format: int32
       * @description The unique identifier of the associated recurring item that this transaction matches.
       */
      recurring_id?: number | null;
      /** @description The new payee for the transaction. */
      payee?: string;
      /**
       * Format: int32
       * @description Unique identifier of the category for this transaction. Set this to null to clear the transaction's category.
       */
      category_id?: number | null;
      /** @description New notes for the transaction. Set this to an empty string to clear the existing notes. */
      notes?: string | null;
      /**
       * Format: int32
       * @description The unique identifier of the manual account associated with this transaction. Set this to null to disassociate the transaction with an account. If set `plaid_account_id` may not also be set to a non null value. Moving an existing transaction to to another account will not work if the transaction belongs to a synced account who's "Allow Modifications to Transactions" property is not set.
       */
      manual_account_id?: number | null;
      /**
       * Format: int32
       * @description The unique identifier of the plaid account associated with this transaction. If set `manual_account_id` may not also be set to a non null value. Attempting to modify this on a transaction associated with a Plaid account will not work if the account's "Allow Modifications to Transactions" property is not set. Similarly, this cannot be set to an id associated with this type of locked Plaid account.
       */
      plaid_account_id?: number | null;
      /** @description A list of tag_ids for the tags associated with this transaction. If set, this property will overwrite any existing tags. Use `additional_tag_ids` to add tags to the existing transaction's tags. Set this to an empty array to remove all tags from a transaction. If set `additional_tag_ids` may not be set. */
      tag_ids?: number[];
      /** @description A list of tag_ids for the tags associated with this transaction. If set, the tags listed in this property be added to any existing transaction tags. Use `tag_ids` to overwrite or clear transaction tags. If set `tag_ids` may not be set. */
      additional_tag_ids?: number[];
      /** @description A user-defined external ID for the transaction. The update will fail if the transaction does not also have a `manual_account_id` or if there is already an existing transaction with the same `manual_account_id`/`external_id` combination. */
      external_id?: string | null;
      /** @description User defined JSON data that can be set or cleared via the API. */
      custom_metadata?: Record<string, never> | null;
      /**
       * @description Status of the transaction, may be one of:
       *     - `reviewed`: User has reviewed the transaction, or it was automatically marked as reviewed due to reviewed recurring_item logic
       *     - `unreviewed`: User has not reviewed the transaction and it does not match any reviewed recurring_items.
       * @enum {string}
       */
      status?: "reviewed" | "unreviewed";
      /**
       * Format: double
       * @description System defined amount of this transaction in the user's primary currency. Ignored if set.
       */
      to_base?: number;
      /** @description System defined flag set for pending transactions. Ignored if set. */
      is_pending?: boolean;
      /** @description System set metadata from a Plaid account sync. Ignored if set. */
      plaid_metadata?: Record<string, never> | null;
      /**
       * Format: date-time
       * @description System defined date and time of when the transaction was created. Ignored if set.
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description System defined date and time of when the transaction was last updated. Ignored if set.
       */
      updated_at?: string;
      /** @description System defined boolean indicating if this transaction was split. To split or unsplit a transaction use the `/transactions/split` endpoint. Ignored if set. */
      is_parent?: boolean;
      /** @description An array of child transactions that exists when a transaction has been split or if the transaction is a group. Split and Grouped transactions may not be modified using this API. Ignored if set. */
      children?: components["schemas"]["childTransactionObject"][];
      /**
       * Format: int64
       * @description A transaction ID if this is a split transaction. Split transactions may not be modified this API. Use the `transactions/split` endpoint instead. Ignored if set.
       */
      parent_id?: number | null;
      /** @description System defined boolean indicating if this transaction represents a group of transactions. Grouped transactions may not be modified with this API. Use the `transactions/group` endpoint instead. Ignored if set. */
      is_group?: boolean;
      /**
       * Format: int64
       * @description A transaction group ID if this transaction is part of a group. Grouped transactions may not be modified with this API. Use the `transactions/group` endpoint instead. Ignored if set.
       */
      group_id?: number | null;
      /**
       * @description System defined original source of the transaction. Ignored if set.
       * @enum {string|null}
       */
      source?:
        | "api"
        | "csv"
        | "manual"
        | "merge"
        | "plaid"
        | "recurring"
        | "rule"
        | "split"
        | "user"
        | null;
    };
    /** @description The object representing a split transaction */
    splitTransactionObject: {
      /** @description Individual amount of split. Currency will inherit from parent transaction. All amounts must sum up to parent transaction amount. */
      amount: number | string;
      /** @description The payee for the child transaction. Will inherit the original payee from the parent if not defined. */
      payee?: string;
      /**
       * Format: date
       * @description Must be in ISO 8601 format (YYYY-MM-DD). Will inherit from the parent if not defined.
       */
      date?: string;
      /**
       * Format: int32
       * @description Unique identifier for associated category_id. Category must already exist for the account. Will inherit category from the parent if not defined.
       */
      category_id?: number;
      /** @description Will inherit notes from parent if not defined. */
      notes?: string;
    };
    /** @description The object returned when a new transaction has an external_id that already exists */
    skippedExistingExternalIdObject: {
      /**
       * @description The reason the transaction was skipped, may be one of:
       *     - `duplicate_external_id`: The transaction has the same `manual_account_id` and `external_id` as an existing transaction
       *     - `duplicate_payee_amount_date`: The `skip_duplicates` request body property was set to `true` and the transaction has the same `amount`, `payee`, and `date` as an existing transaction associated with the same account.
       * @enum {string}
       */
      reason?: "duplicate_external_id" | "duplicate_payee_amount_date";
      /**
       * Format: int64
       * @description The  of the transaction in the request body's transactions array that was skipped.
       */
      request_transactions_index?: number;
      /**
       * Format: int64
       * @description The id of the existing transactions that the requested transaction duplicates.
       */
      existing_transaction_id?: number;
      /** @description The requested transaction that was skipped. */
      request_transaction?: components["schemas"]["insertTransactionObject"];
    };
    /** @description The object returned from a successful POST /transactions request */
    insertTransactionsResponseObject: {
      /** @description An array of the inserted transactions. */
      transactions: components["schemas"]["transactionObject"][];
      /** @description An array of the requested transactions that were duplicates of existing transactions and were not inserted. */
      skipped_duplicates: components["schemas"]["skippedExistingExternalIdObject"][];
    };
    transactionAttachmentObject: {
      /**
       * Format: int32
       * @description The unique identifier of the attachment
       */
      id?: number;
      /**
       * Format: int64
       * @description The id of the user who uploaded the attachment
       */
      uploaded_by?: number;
      /** @description The name of the file */
      name?: string;
      /** @description The MIME type of the file */
      type?: string;
      /** @description The size of the file in kilobytes */
      size?: number;
      /** @description Optional notes about the attachment */
      notes?: string | null;
      /**
       * Format: date-time
       * @description The date and time when the attachment was created in ISO 8601 format
       */
      created_at?: string;
    };
    /** @description An object containing information about a manual account */
    manualAccountObject: {
      /**
       * Format: int32
       * @description The unique identifier of this account
       */
      id: number;
      /** @description Name of the account */
      name: string;
      /** @description Primary type of the account */
      type: components["schemas"]["accountTypeEnum"];
      /** @description Optional account subtype. Examples include<br> - retirement - checking - savings - prepaid credit card */
      subtype: string | null;
      /** @description Optional display name for the account set by the user */
      display_name: string | null;
      /** @description Current balance of the account in numeric format to 4 decimal places. */
      balance: string;
      /** @description Three-letter lowercase currency code of the account balance */
      currency: string;
      /** @description The balance converted to the user's primary currency */
      to_base: number;
      /**
       * Format: date-time
       * @description Date balance was last updated in ISO 8601 extended format, can be in date or date-time format
       */
      balance_as_of: string;
      /**
       * Format: date
       * @description The date this account was closed. Will be null if the account has not been marked as closed
       */
      closed_on: string | null;
      /** @description Name of institution holding the account */
      institution_name: string | null;
      /** @description An optional external_id that may be set or updated via the API */
      external_id: string | null;
      /** @description User defined JSON data that can be set or cleared via the API. */
      custom_metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description If true, this account will not show up as an option for assignment when creating transactions manually
       * @default false
       */
      exclude_from_transactions: boolean;
      /**
       * Format: date-time
       * @description Date/time the account was created in ISO 8601 extended format
       */
      created_at: string;
      /**
       * Format: date-time
       * @description Date/time the account was created in ISO 8601 extended format
       */
      updated_at: string;
    };
    createManualAccountRequestObject: {
      /**
       * @description Name of the manual account
       * @example My Savings Account
       */
      name: string;
      /** @description The type of manual account. */
      type: components["schemas"]["accountTypeEnum"];
      /**
       * @description An optional manual account subtype. Examples include<br> - retirement - checking - savings - prepaid credit card
       * @example prepaid credit card
       */
      subtype?: string;
      /**
       * @description Display name of the manual account as set by user.<br> This must be unique for the budgeting account.  If not set, it will be derived from the `institution_name` (if any) plus `name`.
       * @example Savings
       */
      display_name?: string;
      /**
       * @description Numeric value of the current balance, up to four decimal places, of the account as a number or string. Do not include any special characters aside from a decimal point.
       * @example 195.50
       */
      balance: number | string;
      /**
       * @description Date/time the balance of the manual account was last updated in ISO 8601 extended format
       * @example 2024-09-15
       */
      balance_as_of?: string & (unknown | unknown);
      /**
       * Format: date
       * @description The date this manual account was closed in YYYY-MM-DD format.
       * @example 2024-10-01
       */
      closed_on?: string | null;
      /** @description Three-letter lowercase currency code of the transaction in ISO 4217 format */
      currency?: components["schemas"]["currencyEnum"];
      /**
       * @description Name of institution holding the manual account
       * @example Bank of the West
       */
      institution_name?: string;
      /** @description An optional user-defined ID for the manual account */
      external_id?: string | null;
      /** @description An optional JSON object that includes additional data related to this account. This must be a valid JSON object and, when stringified, must not exceed 4096 characters. */
      custom_metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * @description If `true`, transactions may not be assigned to this manual account.
       * @default false
       */
      exclude_from_transactions: boolean;
    };
    updateManualAccountRequestObject: {
      /**
       * Format: int32
       * @description System defined unique identifier of this account. Ignored if set.
       */
      id?: number;
      /** @description If set, the new name of the manual account. */
      name?: string;
      /** @description If set, the new type of the manual account. */
      type?: components["schemas"]["accountTypeEnum"];
      /** @description If set, an optional account subtype. Examples include<br> - retirement - checking - savings - prepaid credit card */
      subtype?: string;
      /** @description If set, an optional display name for the manual account.<br> This must be unique for the user.  If not set, it will be derived from the `institution_name` (if any) concatenated with the `name`. */
      display_name?: string | null;
      /**
       * @description Numeric value of the current balance, up to four decimal places, of the manual account as a number or string. Do not include any special characters aside from a decimal point.
       * @example 195.50
       */
      balance?: number | string;
      /** @description A new date for the `updated_at` property. May be set as a date, ie: YYYY-MM-DD, or date-time string in ISO 8601 extended format. This property is ignored if `balance` is not also set. If `balance` is set and this property is not set the current time is used. */
      balance_as_of?: string & (unknown | unknown);
      /**
       * Format: date
       * @description If set, the date this manual account was closed in YYYY-MM-DD format.
       */
      closed_on?: string | null;
      /** @description If set, the new three-letter lowercase currency code of the manual account balance. */
      currency?: components["schemas"]["currencyEnum"];
      /** @description If set, the name of institution holding the account. */
      institution_name?: string | null;
      /** @description An optional user-defined ID for the manual account. */
      external_id?: string | null;
      /** @description An optional JSON object that includes additional data related to this account. This must be a valid JSON object and, when stringified, must not exceed 4096 characters. */
      custom_metadata?: {
        [key: string]: unknown;
      } | null;
      /** @description If set, transactions may not be assigned to this manual account. */
      exclude_from_transactions?: boolean;
      /**
       * Format: date-time
       * @description System defined date/time the account was created in ISO 8601 extended format. Ignored if set.
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description System defined date/time the account was created in ISO 8601 extended format. Ignored if set.
       */
      updated_at?: string;
    };
    /** @description An object containing information about an account synced via Plaid */
    plaidAccountObject: {
      /**
       * Format: int32
       * @description The unique identifier of this account
       */
      id: number;
      /**
       * Format: date
       * @description Date account was first linked in ISO 8601 format
       */
      date_linked: string;
      /** @description Name of the account. This field is set by Plaid and cannot be altered. */
      name: string;
      /** @description Optional display name for the account set by the user. If not set, it will return a concatenated string of institution and account name. */
      display_name: string | null;
      /** @description Primary type of the account, such as `credit`, `depository`, etc. This field is set by Plaid and cannot be altered. */
      type: string;
      /** @description Optional account subtype. This field is set by Plaid and cannot be altered. */
      subtype: string;
      /** @description Mask (last 3 to 4 digits of account) of account. This field is set by Plaid and cannot be altered. */
      mask: string;
      /** @description Name of institution holding the account. This field is set by Plaid and cannot be altered. */
      institution_name: string;
      /**
       * @description Denotes the current status of the account within Lunch Money. Must be one of<br> - `active`: Account is active and in good state<br> - `inactive`: Account marked inactive from user. Transaction imports and balance updates will not occur for this account.<br> - `relink`: Account needs to be relinked with Plaid.<br> - `syncing`: Account is awaiting first import of transactions. <br> - `not found`: Account cannot be found with Plaid<br> - `not supported`: Account is not supported with Plaid<br> - `error`: Account is in error with Plaid.<br>
       * @enum {string}
       */
      status:
        | "active"
        | "inactive"
        | "relink"
        | "syncing"
        | "not found"
        | "not supported"
        | "error";
      /** @description If `false`, transactions imported for this synced account can have their properties (such as amount and account) be modified by the user. This option is managed in the web app. */
      allow_transaction_modifications: boolean;
      /** @description Optional credit limit of the account. This field is set by Plaid and cannot be altered */
      limit: number | null;
      /** @description Current balance of the account in numeric format to 4 decimal places. This field is set by Plaid and cannot be altered. */
      balance: string;
      /** @description Three-letter lowercase currency code of the account balance */
      currency: string;
      /** @description The account balance converted to the user's primary currency */
      to_base: number;
      /**
       * Format: date-time
       * @description Date balance was last updated in ISO 8601 extended format. This field is set by Plaid and cannot be altered.
       */
      balance_last_update: string | null;
      /**
       * Format: date
       * @description Date of earliest date allowed for importing transactions. Transactions earlier than this date are not imported.
       */
      import_start_date: string | null;
      /**
       * Format: date-time
       * @description Timestamp in ISO 8601 extended format of the last time Lunch Money imported new data from Plaid for this account.
       */
      last_import: string | null;
      /**
       * Format: date-time
       * @description Timestamp in ISO 8601 extended format of the last successful request from Lunch Money for updated data or timestamps from Plaid in ISO 8601 extended format (not necessarily date of last successful import)
       */
      last_fetch: string | null;
      /**
       * Format: date-time
       * @description Timestamp in ISO 8601 extended format of the last time Plaid successfully connected with institution for new transaction updates, regardless of whether any new data was available in the update.
       */
      plaid_last_successful_update: string | null;
    };
    tagObject: {
      /**
       * Format: int32
       * @description Unique identifier for the tag.
       */
      id: number;
      /** @description Name of the tag. */
      name: string;
      /** @description Description of the tag. */
      description: string | null;
      /** @description The text color of the tag. */
      text_color: string | null;
      /** @description The background color of the tag. */
      background_color: string | null;
      /**
       * Format: date-time
       * @description The date and time of when the tag was last updated (in the ISO 8601 extended format).
       */
      updated_at: string;
      /**
       * Format: date-time
       * @description The date and time of when the tag was created (in the ISO 8601 extended format).
       */
      created_at: string;
      /** @description If `true`, the tag will not show up when creating or updating transactions in the Lunch Money app. **Can it be assigned via the API** */
      archived: boolean;
      /**
       * Format: date-time
       * @description The date and time of when the tag was last archived or `null` if not archived
       */
      archived_at: string | null;
    };
    createTagRequestObject: {
      /**
       * @description The name of the new tag. Must be between 1 and 100 characters.
       *     Must not match the name of any existing tags.
       */
      name: string;
      /**
       * @description The description of the tag. Must not exceed 200 characters.
       * @default null
       */
      description: string | null;
      /** @description The text color of the tag. */
      text_color?: string | null;
      /** @description The background color of the tag. */
      background_color?: string | null;
      /**
       * @description If `true`, the tag is archived and not displayed in relevant areas of the Lunch Money app.
       * @default false
       */
      archived: boolean;
    };
    updateTagRequestObject: {
      /** @description If set, the new name of the category. Must be between 1 and 100 characters. */
      name?: string;
      /** @description If set, the new description of the category. Must not exceed 200 characters. */
      description?: string | null;
      /** @description The text color of the tag. */
      text_color?: string | null;
      /** @description The background color of the tag. */
      background_color?: string | null;
      /** @description If set, will indicate if this category is archived. */
      archived?: boolean;
      /**
       * Format: int32
       * @description System-defined unique identifier for the category. Ignored if set.
       */
      id?: number;
      /**
       * Format: date-time
       * @description System-set time the tag was last updated. Ignored if set
       */
      updated_at?: string;
      /**
       * Format: date-time
       * @description System-set time the tag was created. Ignored if set.
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description System-set time the tag was archived. Ignored if set.
       */
      archived_at?: string | null;
    };
    deleteTagResponseWithDependencies: {
      /** @description The name of the tag */
      tag_name: string;
      dependents: {
        /** @description The number of rules depending on the tag */
        rules: number;
        /** @description The number of transactions with the tag */
        transactions: number;
      };
    };
    recurringObject: {
      /**
       * Format: int32
       * @description The unique identifier of this recurring item
       */
      id: number;
      /** @description An optional description of this recurring item. */
      description: string | null;
      /**
       * @description The status of this recurring item. `suggested` recurring items are generated by Lunch Money, but only `reviewed` recurring items will be applied to matching transactions.
       * @enum {string}
       */
      status: "suggested" | "reviewed";
      /** @description The set of properties used to identify matching transactions. */
      transaction_criteria: {
        /**
         * Format: date
         * @description The beginning of the date range for matching transactions. If `null`, any transactions before end_date may be considered.
         */
        start_date: string | null;
        /**
         * Format: date
         * @description The end of the date range for matching transactions. If `null`, any transactions after start_date may be considered.
         */
        end_date: string | null;
        /**
         * @description The unit of time used to define the cadence of the recurring item.
         * @enum {string}
         */
        granularity: "day" | "week" | "month" | "year";
        /** @description The number of granularity units between each recurrence. */
        quantity: number;
        /**
         * Format: date
         * @description The date used in conjunction with the `quantity` and `granularity` properties to calculate expected occurrences of recurring transactions.
         */
        anchor_date: string;
        /** @description If set, represents the original transaction payee name that triggered this recurring item's creation. */
        payee: string | null;
        /** @description The expected amount for a transaction that will match this recurring item. For recurring items that have a flexible amount this is the average of the specified min and max amounts. */
        amount: string;
        /** @description The amount converted to the user's primary currency */
        to_base: number;
        /** @description Three-letter lowercase currency code of the recurring item. */
        currency: string;
        /**
         * Format: int64
         * @description The Plaid account ID associated with the recurring item, if any.
         */
        plaid_account_id: number | null;
        /**
         * Format: int64
         * @description The manual account ID associated with the recurring item, if any.
         */
        manual_account_id: number | null;
      };
      /** @description The values that will be applied to matching transactions. */
      overrides: {
        /** @description If present, the payee name that will be displayed for any matching transactions. */
        payee?: string;
        /** @description If present, the notes that will be displayed for any matching transactions. */
        notes?: string;
        /** @description If present, the ID of the category that matching transactions will be assigned to. */
        category_id?: number;
      };
      /** @description Details on expected, found and missing transactions for the specified range. This will be `null` for recurring items with a `status` of `suggested`. */
      matches: {
        /**
         * Format: date
         * @description The beginning of the date range that this request used to find matching transactions.
         */
        request_start_date?: string;
        /**
         * Format: date
         * @description The beginning of the date range that this request used to find matching transactions.
         */
        request_end_date?: string;
        /** @description A list of dates within the specified range where a recurring transactions is expected. */
        expected_occurrence_dates?: string[];
        /** @description A list with the dates and IDs of matching transactions. */
        found_transactions?: {
          /**
           * Format: date
           * @description The date for a matching transaction within the specified range.
           */
          date?: string;
          /** @description The ID of a matching transaction within the specified range. */
          transaction_id?: number;
        }[];
        /** @description A list of dates within the range of where a recurring transaction was expected but none was found. */
        missing_transaction_dates?: string[];
      } | null;
      /** @description The ID of the user who created the recurring item. */
      created_by: number;
      /**
       * Format: date-time
       * @description Date/time the recurring item was created in ISO 8601 extended format.
       */
      created_at: string;
      /**
       * Format: date-time
       * @description Date/time the recurring item was updated in ISO 8601 extended format.
       */
      updated_at: string;
      /**
       * @description This can be one of four values:
       *     - `manual`: User created this recurring item manually from the Recurring Items page
       *     - `transaction`: User created this by converting a transaction from the Transactions page
       *     - `system`: Recurring item was created by the system on transaction import
       *     - `null`: Some older recurring items may not have a source.
       * @enum {string}
       */
      source: "manual" | "transaction" | "system";
    };
    errorResponseObject: {
      /** @description overall error message */
      message: string;
      errors: ({
        /** @description Human-readable error message */
        errMsg: string;
      } & {
        [key: string]: unknown;
      })[];
    };
    /** @enum {string} */
    accountTypeEnum:
      | "cash"
      | "credit"
      | "cryptocurrency"
      | "employee compensation"
      | "investment"
      | "loan"
      | "other liability"
      | "other asset"
      | "real estate"
      | "vehicle";
    /** @enum {string} */
    currencyEnum:
      | "aed"
      | "afn"
      | "all"
      | "amd"
      | "ang"
      | "aoa"
      | "ars"
      | "aud"
      | "awg"
      | "azn"
      | "bam"
      | "bbd"
      | "bdt"
      | "bgn"
      | "bhd"
      | "bif"
      | "bmd"
      | "bnd"
      | "bob"
      | "brl"
      | "bsd"
      | "btc"
      | "btn"
      | "bwp"
      | "byn"
      | "bzd"
      | "cad"
      | "cdf"
      | "chf"
      | "clp"
      | "cny"
      | "cop"
      | "crc"
      | "cuc"
      | "cup"
      | "cve"
      | "czk"
      | "djf"
      | "dkk"
      | "dop"
      | "dzd"
      | "egp"
      | "ern"
      | "etb"
      | "eur"
      | "fjd"
      | "fkp"
      | "gbp"
      | "gel"
      | "ggp"
      | "ghs"
      | "gip"
      | "gmd"
      | "gnf"
      | "gtq"
      | "gyd"
      | "hkd"
      | "hnl"
      | "hrk"
      | "htg"
      | "huf"
      | "idr"
      | "ils"
      | "imp"
      | "inr"
      | "iqd"
      | "irr"
      | "isk"
      | "jep"
      | "jmd"
      | "jod"
      | "jpy"
      | "kes"
      | "kgs"
      | "khr"
      | "kmf"
      | "kpw"
      | "krw"
      | "kwd"
      | "kyd"
      | "kzt"
      | "lak"
      | "lbp"
      | "lkr"
      | "lrd"
      | "lsl"
      | "ltl"
      | "lvl"
      | "lyd"
      | "mad"
      | "mdl"
      | "mga"
      | "mkd"
      | "mmk"
      | "mnt"
      | "mop"
      | "mro"
      | "mur"
      | "mvr"
      | "mwk"
      | "mxn"
      | "myr"
      | "mzn"
      | "nad"
      | "ngn"
      | "nio"
      | "nok"
      | "npr"
      | "nzd"
      | "omr"
      | "pab"
      | "pen"
      | "pgk"
      | "php"
      | "pkr"
      | "pln"
      | "pyg"
      | "qar"
      | "ron"
      | "rsd"
      | "rub"
      | "rwf"
      | "sar"
      | "sbd"
      | "scr"
      | "sdg"
      | "sek"
      | "sgd"
      | "shp"
      | "sll"
      | "sos"
      | "srd"
      | "std"
      | "svc"
      | "syp"
      | "szl"
      | "thb"
      | "tjs"
      | "tmt"
      | "tnd"
      | "top"
      | "try"
      | "ttd"
      | "twd"
      | "tzs"
      | "uah"
      | "ugx"
      | "usd"
      | "uyu"
      | "uzs"
      | "vef"
      | "vnd"
      | "vuv"
      | "wst"
      | "xaf"
      | "xcd"
      | "xof"
      | "xpf"
      | "yer"
      | "zar"
      | "zmw"
      | "zwl";
    /** aligned summary response object */
    alignedSummaryResponseObject: {
      totals?: components["schemas"]["summaryTotalsObject"];
      /**
       * @description `true` if start_date and end_date are aligned with budget period setting
       * @enum {boolean}
       */
      aligned: true;
      categories: components["schemas"]["alignedSummaryCategoryObject"][];
    };
    /** non-aligned summary response object */
    nonAlignedSummaryResponseObject: {
      totals?: components["schemas"]["summaryTotalsObject"];
      /**
       * @description `true` if start_date and end_date are aligned with budget period setting
       * @enum {boolean}
       */
      aligned: false;
      categories: components["schemas"]["nonAlignedSummaryCategoryObject"][];
    };
    /** @description Total inflow and outflow for the given date range.  This object is returned when the query parameter `include_totals` is set to `true`. */
    summaryTotalsObject: {
      inflow?: components["schemas"]["summaryTotalsBreakdownObject"];
      outflow?: components["schemas"]["summaryTotalsBreakdownObject"];
    };
    summaryTotalsBreakdownObject: {
      /** @description Total amount, in the user's default currency, of non recurring activity for the given date range. */
      other_activity?: number;
      /** @description Total amount, in the user's default currency, of recurring activity that has occurred for the given date range. */
      recurring_activity?: number;
      /** @description Total amount, in the user's default currency, of expected recurring activity that has not yet occurred. */
      recurring_remaining?: number;
      /** @description Total amount, in the user's default currency, of non recurring activity coming from un-categorized transactions. */
      uncategorized?: number;
      /** @description Number of un-categorized transactions for the given date range. */
      uncategorized_count?: number;
      /** @description Total amount, in the user's default currency, of recurring activity coming from un-categorized transactions. */
      uncategorized_recurring?: number;
    };
    /** @description List of each category's budget configuration and activity for the given date range. */
    alignedSummaryCategoryObject: {
      /** @description ID of the category associated with the totals. */
      category_id: number;
      totals: components["schemas"]["alignedCategoryTotalsObject"];
      occurrences?: components["schemas"]["summaryCategoryOccurrenceObject"][];
    };
    /** @description List of each category's budget configuration and activity for the given date range.<br> Does not include occurrences since the start_date and end_date are not aligned with budget period setting. */
    nonAlignedSummaryCategoryObject: {
      /** @description ID of the category associated with the totals. */
      category_id: number;
      totals: components["schemas"]["nonAlignedCategoryTotalsObject"];
    };
    /** @description The date and adjusted balance of the rollover pool at the time of the adjustment. */
    summaryRolloverPoolAdjustmentObject: {
      /** @description true if this is the current rollover pool balance. */
      current: boolean;
      /** Format: date */
      date: string;
      /** @description Amount of the rollover pool at the time of the adjustment. */
      amount: string;
      /** @description Currency of the rollover pool at the time of the adjustment. */
      currency: components["schemas"]["currencyEnum"];
      /** @description Amount of the rollover pool converted to the user's default currency. */
      to_base: number;
    };
    /** @description Total activity for the given category within the given date range which is aligned with budget period setting. */
    alignedCategoryTotalsObject: {
      /** @description Total non recurring activity, in the user's default currency, for the category within the given date range.<br> The total activity for the category is the sum of this and the recurring_activity. */
      other_activity: number;
      /** @description Total recurring activity, in the user's default currency, for the category within the given date range.<br> The total activity for the category is the sum of this and the other_activity. */
      recurring_activity: number;
      /** @description Total budgeted amount, in the user's default currency, for the category within the given date range or null if the category is not budgeted. */
      budgeted: number | null;
      /** @description Total amount of funds available, in the user's default currency, for the category within the given date range. */
      available: number | null;
      /** @description Total expected recurring activity, in the user's default currency, that has not yet occurred for the category within the given date range. */
      recurring_remaining: number;
      /** @description Total expected recurring activity for the category within the given date range. */
      recurring_expected: number;
    };
    /** @description Total activity for the given category within the given date range which is not aligned with budget period setting. */
    nonAlignedCategoryTotalsObject: {
      /** @description Total non recurring activity, in the user's default currency, for the category within the given date range.<br> The total activity for the category is the sum of this and the recurring_activity. */
      other_activity: number;
      /** @description Total recurring activity, in the user's default currency, for the category within the given date range.<br> The total activity for the category is the sum of this and the other_activity. */
      recurring_activity: number;
      /** @description Total expected recurring activity, in the user's default currency, that has not yet occurred for the category within the given date range. */
      recurring_remaining: number;
      /** @description Total expected recurring activity for the category within the given date range. */
      recurring_expected: number;
    };
    /** @description Per period budget activity for the each budget period within the given date range.<br> This is only returned if the query parameter `include_occurrences` is set to `true`. */
    summaryCategoryOccurrenceObject: {
      /** @description true if this occurrence is the current budget period. */
      current: boolean;
      /**
       * Format: date
       * @description The start date of the budget period.
       */
      start_date: string;
      /**
       * Format: date
       * @description The end date of the budget period.
       */
      end_date: string;
      /** @description Total non recurring activity, in the user's default currency, for the category within the given date range. The total activity for the category is the sum of this and the recurring_activity. */
      other_activity: number;
      /** @description Total recurring activity, in the user's default currency, for the category within the given date range. The total activity for the category is the sum of this and the other_activity. */
      recurring_activity: number;
      /** @description Total budgeted amount, in the user's default currency, for the category within the given date range, or null if the category is not budgeted. */
      budgeted: number | null;
      /** @description Total budgeted amount in the budgeted currency for the category within the given date or null if the category is not budgeted. */
      budgeted_amount: string | null;
      /** @description Currency of the budgeted amount. */
      budgeted_currency: components["schemas"]["currencyEnum"] | null;
      /** @description Any notes added in the Web UI for the budget period. */
      notes: string | null;
    };
    /** @description A single transaction associated with a recurring item. I don't think we will expose this in the summary since it's gettable by querying the recurring_id */
    summaryRecurringTransactionObject: {
      /** Format: date */
      date: string;
      category_id: number;
      payee: string;
      to_base: number;
      amount: string;
      currency: components["schemas"]["currencyEnum"];
    };
    /** @description Summary of the current rollover pool balance and all previous adjustments.<br> Only present if the `include_rollover_pool` query parameter is set to `true`. */
    summaryRolloverPoolObject: {
      /** @description Amount of funds, in the user's default currency, currently available to rollover. */
      budgeted_to_base: number;
      /** @description List of previous adjustments to the rollover pool. */
      all_adjustments: components["schemas"]["summaryRolloverPoolAdjustmentObject"][];
    };
  };
  responses: {
    /** @description Unauthorized. This error occurs when an invalid API token is passed to the request. */
    unauthorizedToken: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "message": "Unauthorized",
         *       "errors": [
         *         {
         *           "errMsg": "Access token does not exist."
         *         }
         *       ]
         *     }
         */
        "application/json": components["schemas"]["errorResponseObject"];
      };
    };
    /** @description Too Many Requests. Retry your request after the number of seconds specified in the retry-after header. */
    rateLimited: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "message": "Too Many Requests",
         *       "errors": [
         *         {
         *           "errMsg": "Too many requests, please try again later."
         *         }
         *       ]
         *     }
         */
        "application/json": components["schemas"]["errorResponseObject"];
      };
    };
    /** @description Internal Server Error. Contact support. */
    serverError: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "message": "Internal Server Error",
         *       "errors": [
         *         {
         *           "errMsg": "Currently in maintenance mode. Please try again in a few minutes."
         *         }
         *       ]
         *     }
         */
        "application/json": components["schemas"]["errorResponseObject"];
      };
    };
  };
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getMe: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The User Object associated with the authorized token. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "name": "User 1",
           *       "email": "user-1@lunchmoney.dev",
           *       "id": 18328,
           *       "account_id": 18221,
           *       "budget_name": "\\U0001F3E0 Family budget",
           *       "primary_currency": "usd",
           *       "api_key_label": "Side project dev key"
           *     }
           */
          "application/json": components["schemas"]["userObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getBudgetSummary: {
    parameters: {
      query: {
        /** @description Start of date range in ISO 8601 date format (YYYY-MM-DD). */
        start_date: string;
        /** @description End of date range in ISO 8601 date format (YYYY-MM-DD). */
        end_date: string;
        /** @description Enable to include categories that have the 'Exclude from Budgets' flag set in the returned `categories` array. */
        include_exclude_from_budgets?: boolean;
        /** @description Enable to include an `occurrences` array for each category in an aligned response. Each array will include an object for each budget period that falls within the specified date range which includes details on the activity for the budget period. */
        include_occurrences?: boolean;
        /** @description Enable to include a top-level `totals` section that summarizes the inflow and outflow across all transactions for the specified date range. */
        include_totals?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Budget summary for the requested range. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json":
            | components["schemas"]["alignedSummaryResponseObject"]
            | components["schemas"]["nonAlignedSummaryResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getAllCategories: {
    parameters: {
      query?: {
        /** @description If `nested`, returns top-level categories (either category groups or categories not part of a category group) in alphabetical order. Grouped categories are nested within the category group under the property `children`. A `flattened`, response is similar but it includes grouped categories at the top level.<br/><br/> Categories are sorted by their `order`. When `order` is null, they are listed in alphabetical order below other categories with an `order`. */
        format?: "nested" | "flattened";
        /** @description If `false`, only categories not part of a category group are returned.<br> If `true`, only category groups are returned.<br> When set, the `format` parameter is ignored. */
        is_group?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A list of Category Objects */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            categories?: components["schemas"]["categoryObject"][];
          };
        };
      };
      /** @description Invalid request parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be equal to one of the allowed values",
           *           "instancePath": "/query/format",
           *           "schemaPath": "#/properties/query/properties/format/enum",
           *           "keyword": "enum",
           *           "params": {
           *             "allowedValues": [
           *               "flattened",
           *               "nested"
           *             ]
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  createCategory: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["createCategoryRequestObject"];
      };
    };
    responses: {
      /** @description Category or Category Group Object with the successfully created category or category group. */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["categoryObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Invalid Request Body",
           *       "errors": [
           *         {
           *           "errMsg": "Cannot specify a 'group_id' in request body if 'is_group' is also true"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getCategoryById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the category to retrieve */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Category Object with the requested category or category group. */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["categoryObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be a valid integer",
           *           "instancePath": "/query/ids/0",
           *           "schemaPath": "#/properties/query/properties/ids/items/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no category with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  updateCategory: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the category to update */
        id: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["updateCategoryRequestObject"];
      };
    };
    responses: {
      /** @description Category or Category Group updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["categoryObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Invalid Request Body",
           *       "errors": [
           *         {
           *           "errMsg": "Cannot modify the 'group_id' property of an existing category or category group"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no category with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  deleteCategory: {
    parameters: {
      query?: {
        /** @description Set to `true` to force deletion even if there are dependencies */
        force?: boolean;
      };
      header?: never;
      path: {
        /** @description ID of the category to delete */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no category with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["deleteCategoryResponseWithDependencies"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getAllManualAccounts: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A list of manual accounts */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "manual_accounts": [
           *         {
           *           "id": 119807,
           *           "name": "Individual Brokerage",
           *           "type": "investment",
           *           "subtype": "brokerage",
           *           "display_name": null,
           *           "balance": "41211.8000",
           *           "balance_as_of": "2025-06-25T17:00:04.000Z",
           *           "closed_on": null,
           *           "currency": "usd",
           *           "to_base": 41211.8,
           *           "institution_name": "Fidelity",
           *           "external_id": null,
           *           "exclude_from_transactions": false,
           *           "created_at": "2025-06-25T17:00:04.414Z",
           *           "updated_at": "2025-06-26T19:03:38.312Z"
           *         },
           *         {
           *           "id": 119909,
           *           "name": "Euro Travel Card",
           *           "type": "credit",
           *           "subtype": "credit card",
           *           "display_name": null,
           *           "balance": "1004.8000",
           *           "balance_as_of": "2023-06-25T17:00:04.000Z",
           *           "closed_on": null,
           *           "currency": "usd",
           *           "to_base": 1004.8,
           *           "institution_name": "WeBank",
           *           "external_id": null,
           *           "exclude_from_transactions": false,
           *           "created_at": "2025-06-25T17:00:04.414Z",
           *           "updated_at": "2025-06-26T19:03:38.312Z"
           *         }
           *       ]
           *     }
           */
          "application/json": {
            manual_accounts?: components["schemas"]["manualAccountObject"][];
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must NOT have additional properties",
           *           "instancePath": "/query",
           *           "schemaPath": "#/properties/query/additionalProperties",
           *           "keyword": "additionalProperties",
           *           "params": {
           *             "additionalProperty": "foo"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  createManualAccount: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["createManualAccountRequestObject"];
      };
    };
    responses: {
      /** @description Successfully created manual account */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["manualAccountObject"];
        };
      };
      /** @description Invalid request body */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getManualAccountById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the manual account to retrieve */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Manual Account Object with the requested account. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "id": 119807,
           *       "name": "Individual Brokerage",
           *       "type": "investment",
           *       "subtype": "brokerage",
           *       "display_name": null,
           *       "balance": "41211.8000",
           *       "balance_as_of": "2025-06-25T17:00:04.000Z",
           *       "closed_on": null,
           *       "currency": "usd",
           *       "to_base": 41211.8,
           *       "institution_name": "Fidelity",
           *       "external_id": null,
           *       "exclude_from_transactions": false,
           *       "created_at": "2025-06-25T17:00:04.414Z",
           *       "updated_at": "2025-06-26T19:03:38.312Z"
           *     }
           */
          "application/json": components["schemas"]["manualAccountObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no manual account with the id:'9999999999999'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  updateManualAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the manual account to update */
        id: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["updateManualAccountRequestObject"];
      };
    };
    responses: {
      /** @description Manual Account updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["manualAccountObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no manual account with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  deleteManualAccount: {
    parameters: {
      query?: {
        /** @description When set to true will also delete any transactions, rules, and recurring items associated with this account. Use this option with caution, it is irreversible! */
        delete_items?: boolean;
        /** @description When set to true will delete any balance history associated with this account. */
        delete_balance_history?: boolean;
      };
      header?: never;
      path: {
        /** @description ID of the manual account to delete */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no manual account with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getAllPlaidAccounts: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A list of accounts synced via Plaid */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "plaid_accounts": [
           *         {
           *           "id": 119804,
           *           "date_linked": "2020-01-28",
           *           "name": "401k",
           *           "display_name": "",
           *           "type": "brokerage",
           *           "subtype": "401k",
           *           "mask": "7468",
           *           "institution_name": "Vanguard",
           *           "status": "inactive",
           *           "allow_transaction_modifications": false,
           *           "limit": null,
           *           "balance": "12345.6700",
           *           "currency": "usd",
           *           "to_base": 12345.67,
           *           "balance_last_update": "2020-01-27T01:38:11.862Z",
           *           "import_start_date": "2023-01-01",
           *           "last_import": "2019-09-04T12:57:09.190Z",
           *           "last_fetch": "2020-01-28T01:38:11.862Z",
           *           "plaid_last_successful_update": "2020-01-27T01:38:11.862Z"
           *         },
           *         {
           *           "id": 119805,
           *           "date_linked": "2020-01-28",
           *           "name": "Freedom",
           *           "display_name": "Penny's Visa",
           *           "type": "credit",
           *           "subtype": "credit card",
           *           "mask": "1973",
           *           "institution_name": "Chase",
           *           "status": "active",
           *           "allow_transaction_modifications": true,
           *           "limit": 15000,
           *           "balance": "0.0000",
           *           "currency": "usd",
           *           "to_base": 0,
           *           "balance_last_update": "2023-01-27T01:38:07.460Z",
           *           "import_start_date": "2023-01-01",
           *           "last_import": "2023-01-24T12:57:03.250Z",
           *           "last_fetch": "2023-01-28T01:38:11.862Z",
           *           "plaid_last_successful_update": "2023-01-27T01:38:11.862Z"
           *         },
           *         {
           *           "id": 119806,
           *           "date_linked": "2020-01-28",
           *           "name": "Checking",
           *           "display_name": "Penny's Checking",
           *           "type": "cash",
           *           "subtype": "checking",
           *           "mask": "2046",
           *           "institution_name": "Western Bank",
           *           "status": "active",
           *           "allow_transaction_modifications": true,
           *           "limit": null,
           *           "balance": "5498.2800",
           *           "currency": "usd",
           *           "to_base": 5498.28,
           *           "balance_last_update": "2023-01-27T01:38:07.460Z",
           *           "import_start_date": "2023-01-01",
           *           "last_import": "2023-01-24T12:57:03.250Z",
           *           "last_fetch": "2023-01-28T01:38:11.862Z",
           *           "plaid_last_successful_update": "2023-01-27T01:38:11.862Z"
           *         }
           *       ]
           *     }
           */
          "application/json": {
            plaid_accounts?: components["schemas"]["plaidAccountObject"][];
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must NOT have additional properties",
           *           "instancePath": "/query",
           *           "schemaPath": "#/properties/query/additionalProperties",
           *           "keyword": "additionalProperties",
           *           "params": {
           *             "additionalProperty": "foo"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getPlaidAccountById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the plaid account to retrieve */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Plaid Account Object with the requested account. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "id": 119805,
           *       "date_linked": "2020-01-28",
           *       "name": "Freedom",
           *       "display_name": "Penny's Visa",
           *       "type": "credit",
           *       "subtype": "credit card",
           *       "mask": "1973",
           *       "institution_name": "Chase",
           *       "status": "active",
           *       "allow_transaction_modifications": true,
           *       "limit": 15000,
           *       "balance": "0.0000",
           *       "currency": "usd",
           *       "to_base": 0,
           *       "balance_last_update": "2023-01-27T01:38:07.460Z",
           *       "import_start_date": "2023-01-01",
           *       "last_import": "2023-01-24T12:57:03.250Z",
           *       "last_fetch": "2023-01-28T01:38:11.862Z",
           *       "plaid_last_successful_update": "2023-01-27T01:38:11.862Z"
           *     }
           */
          "application/json": components["schemas"]["plaidAccountObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be integer",
           *           "instancePath": "/path/id",
           *           "schemaPath": "#/properties/path/properties/ids/items/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no plaid account with the id: 9999999999999"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  triggerPlaidAccountFetch: {
    parameters: {
      query?: {
        /** @description Denotes the beginning of the time period to fetch transactions for. If omitted, the most recent transactions will be returned. <br> Required if end_date exists. <br> */
        start_date?: string;
        /** @description Denotes the end of the time period you'd like to get transactions for. Required if start_date exists. */
        end_date?: string;
        /** @description Specific ID of a plaid account to fetch. If not set the endpoint will trigger a fetch for all eligible accounts. */
        id?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A 202 ACCEPTED status is returned if Plaid acknowledged the fetch request. This indicates that it is possible to subsequently query the `GET /plaid_accounts` endpoint to determine if the request was successful (`plaid_last_successful_update` is more recent than `last_fetch), or if new transactions were synced (`last_import` is more recent than `last_fetch`).<br> */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Too Early */
      425: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Too Early",
           *       "errors": [
           *         {
           *           "errMsg": "Please wait at least 60 seconds between fetch requests."
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getAllTransactions: {
    parameters: {
      query?: {
        /** @description Denotes the beginning of the time period to fetch transactions for. If omitted, the most recent transactions will be returned. See `limit`. Required if end_date exists. <br> */
        start_date?: string;
        /** @description Denotes the end of the time period you'd like to get transactions for. Required if start_date exists. */
        end_date?: string;
        /** @description Filter transactions to those associated with specified manual account ID or set this to 0 to omit any transactions from manual accounts. Setting both this and `synched_account_id` to 0 will return transactions with no account. These are listed as "Cash Transactions" in the Lunch Money GUI. */
        manual_account_id?: number;
        /** @description Filter transactions to those associated with specified plaid account ID or set this to 0 to omit any transactions from plaid accounts. Setting both this and `manual_account_id` to 0 will return transactions with no account. These are listed as "Cash Transactions" in the Lunch Money GUI. */
        plaid_account_id?: number;
        /** @description Filter transactions to those associated with specified Recurring  Item ID */
        recurring_id?: number;
        /** @description Filter transactions to those associated with the specified category ID. Will also match category groups.  Set this to 0 to return only un-categorized transactions */
        category_id?: number;
        /** @description Filter transactions to those that have a tag with the specified Tag ID */
        tag_id?: number;
        /** @description Filter by group (returns only transaction groups if `true`) */
        is_group?: boolean;
        /** @description Filter transactions to those with the specified status:<br> - `reviewed`: Only user reviewed transactions or those that were automatically marked as reviewed due to reviewed recurring_item logic<br> - `unreviewed`: Only transactions that need to be reviewed<br> - `delete_pending`: Only transactions that require manual intervention because the plaid account deleted this transaction after it was updated by the user. */
        status?: "reviewed" | "unreviewed" | "delete_pending";
        /** @description Filter transactions by pending status. Set to `true` to return only pending transactions, or `false` to return only non-pending transactions. When this parameter is set, it takes precedence over `include_pending`. Note: Pending transactions always have a status of `unreviewed`, so when setting this parameter to `true`, either omit the `status` parameter or set it to `unreviewed`. */
        is_pending?: boolean;
        /** @description By default, pending transactions are excluded from results. Set to `true` to include imported transactions with a pending status in the results. This query param is ignored if the `is_pending` query param is also set. */
        include_pending?: boolean;
        /** @description By default, custom and plaid metadata are not included in the response.  Set to true if you'd like the returned transactions objects to include any  metadata associated with the transactions. */
        include_metadata?: boolean;
        /** @description By default, transactions that were split into multiple transactions are not included in the response. Set to true if you'd like the returned transactions objects to include any  transactions that were split into multiple transactions.  Use with caution as this data is normally not exposed after the split transactions are created. */
        include_split_parents?: boolean;
        /** @description By default, the `children` property is not included in the response. Set to true if you'd like the children property to be populated with the transactions that  make up a transaction group, or, if the `include_split_parents` query param is also set,  the transactions that were split from a parent transaction. */
        include_children?: boolean;
        /** @description By default, the `files` property is not included in the response. Set to true if you'd like the responses to include a list of of  objects that describe any files attached to the transactions. */
        include_files?: boolean;
        /** @description Sets the maximum number of transactions to return. If more match the filter criteria, the response will include a `has_more` attribute set to `true`. See [pagination](foo) */
        limit?: number;
        /** @description Sets the offset for the records returned. This is typically set automatically in the header. See [Pagination](/foo) */
        offset?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns an array of transactions. <br><br>The `has_more` property is set to `true` if more transactions are available. See [Pagination](/foo) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            transactions: components["schemas"]["transactionObject"][];
            /** @description Set to true if more transactions are available */
            has_more: boolean;
            error?: string;
          };
        };
      };
      /** @description Invalid request parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be integer",
           *           "instancePath": "/query/category_id",
           *           "schemaPath": "#/properties/query/properties/category_id/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  updateTransactions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description List of transactions to update. Each transaction must have an `id` property and at least one other property to update. */
          transactions: ({
            /**
             * Format: int64
             * @description The ID of the transaction to update
             */
            id: number;
          } & components["schemas"]["updateTransactionObject"])[];
        };
      };
    };
    responses: {
      /** @description Transactions successfully updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            transactions: components["schemas"]["transactionObject"][];
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  createNewTransactions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description List of transactions to insert. */
          transactions: components["schemas"]["insertTransactionObject"][];
          /**
           * @description If `true`, any rules associated with the account specified by the `manual_account_id` property for each transaction will be applied.
           * @default false
           */
          apply_rules?: boolean;
          /**
           * @description If `true`, the system will flag new transactions that have the same `date`, `payee`, `amount`, and account_id (plaid or manual), as an existing transaction, as a duplicate. <br><br> Note that deduplication based on `external_id` will always occur regardless of how this property is set.
           * @default false
           */
          skip_duplicates?: boolean;
          /**
           * @description If `true`, and new transactions include a `manual_account_id`, the balances of these accounts will not be updated, when the transactions are inserted.
           * @default false
           */
          skip_balance_update?: boolean;
        };
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["insertTransactionsResponseObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  deleteTransactions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of existing Transaction IDs to delete */
          ids: number[];
        };
      };
    };
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not Found */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Invalid Request Body",
           *       "errors": [
           *         {
           *           "errMsg": "Duplicate transaction ID found: 2112150653",
           *           "transaction_id": 2112150653,
           *           "ids_index": 0,
           *           "invalid_property": "ids"
           *         },
           *         {
           *           "errMsg": "Duplicate transaction ID found: 2112150653",
           *           "transaction_id": 2112150653,
           *           "ids_index": 1,
           *           "invalid_property": "ids"
           *         },
           *         {
           *           "errMsg": "Duplicate transaction ID found: 2112150654",
           *           "transaction_id": 2112150654,
           *           "ids_index": 2,
           *           "invalid_property": "ids"
           *         },
           *         {
           *           "errMsg": "Duplicate transaction ID found: 2112150654",
           *           "transaction_id": 2112150654,
           *           "ids_index": 3,
           *           "invalid_property": "ids"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "There is no transaction with the id: 8888888888",
           *           "ids_index": 0,
           *           "id": 8888888888
           *         },
           *         {
           *           "errMsg": "There is no transaction with the id: 9999999999",
           *           "ids_index": 1,
           *           "id": 9999999999
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getTransactionById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the transaction to retrieve */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Transaction Object with the requested transaction. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["transactionObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be integer",
           *           "instancePath": "/path/id",
           *           "schemaPath": "#/properties/path/properties/id/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no transaction with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  updateTransaction: {
    parameters: {
      query?: {
        /** @description Set this to `false` to skip updating the transaction's associated account balance. Default behavior is to update balances. */
        update_balance?: boolean;
      };
      header?: never;
      path: {
        /** @description ID of the transaction to update */
        id: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["updateTransactionObject"];
      };
    };
    responses: {
      /** @description Transaction successfully updated */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["transactionObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be integer",
           *           "instancePath": "/path/id",
           *           "schemaPath": "#/properties/path/properties/id/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no transaction with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  deleteTransactionById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the transaction to delete */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no transaction with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  groupTransactions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description List of existing transaction IDs to group. Split and recurring transactions may not be grouped. Transactions that are already grouped must be ungrouped before being regrouped. */
          ids: number[];
          /**
           * Format: date
           * @description Date for the new grouped transaction in ISO 8601 format.
           */
          date: string;
          /** @description The payee for the new grouped transaction. */
          payee: string;
          /**
           * Format: int64
           * @description The ID of an existing category to assign to the grouped transaction. If not set and all the grouped transactions have the same category, the grouped transaction will inherit the category, otherwise the new transaction will have no category.
           */
          category_id?: number | null;
          /** @description Notes for the grouped transaction. */
          notes?: string | null;
          /**
           * @description If set must be either `reviewed` or `unreviewed`. If not set, defaults to `reviewed`.
           * @enum {string}
           */
          status?: "reviewed" | "unreviewed";
          /** @description A list of IDs for the tags associated with the grouped transaction. Each ID must match an existing tag associated with the user's account. If not set, no tags will be associated with the created transaction. */
          tag_ids?: number[];
        };
      };
    };
    responses: {
      /** @description The new grouped parent transaction with populated children attribute */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["transactionObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  ungroupTransactions: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the transaction group to delete */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no transaction with the id: 543210"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  splitTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the transaction to spit */
        id: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** @description List of child transactions to create. The sum of the `amounts` must match the split transaction amount. */
          child_transactions: components["schemas"]["splitTransactionObject"][];
        };
      };
    };
    responses: {
      /** @description The new split parent transaction with populated children attribute */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["transactionObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  unsplitTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the previously split transaction to delete. */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Invalid request parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no transaction with the id: 2112140458",
           *           "id": 2112140458
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  attachFileToTransaction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        transaction_id: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        /**
         * @example {
         *       "file": "./test-attachment.png",
         *       "notes": "Test file attachment"
         *     }
         */
        "multipart/form-data": {
          /**
           * Format: binary
           * @description The file to attach via multipart form encoding.  File size may not exceed 10MB.
           */
          file: string;
          /** @description Optional notes about the file */
          notes?: string;
        };
      };
    };
    responses: {
      /** @description File attached successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "id": 1234567890,
           *       "uploaded_by": 1,
           *       "name": "receipt.png",
           *       "type": "image/png",
           *       "size": 4330,
           *       "notes": null,
           *       "source": "api",
           *       "created_at": "2025-06-11T22:33:20.294Z"
           *     }
           */
          "application/json": components["schemas"]["transactionAttachmentObject"];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Transaction not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getTransactionAttachmentUrl: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        file_id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successfully retrieved the file attachment */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "url": "https://files.lunchmoney.app/66938-41ebb56a066bf09898de.png?X-Header1=X-Value1&X-Header2=Test-Do-Not-Use",
           *       "expires_at": "2025-07-14T12:00:00Z"
           *     }
           */
          "application/json": {
            /** @description The signed url to download the file attachment */
            url: string;
            /**
             * Format: date-time
             * @description The date and time the signed url will expire
             */
            expires_at: string;
          };
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description File attachment not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "File attachment 1234567890 not found"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
    };
  };
  deleteTransactionAttachment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        file_id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description File attachment successfully deleted */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description File attachment not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "File attachment 1234567890 not found"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
    };
  };
  getAllTags: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A list of tags */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "tags": [
           *         {
           *           "id": 94317,
           *           "name": "Penny's",
           *           "description": "For transactions not related to Lenny",
           *           "updated_at": "2025-02-28T09:49:03.238Z",
           *           "created_at": "2025-01-28T09:49:03.238Z",
           *           "text_color": "333",
           *           "background_color": "FFE7D4",
           *           "archived": false,
           *           "archived_at": null
           *         },
           *         {
           *           "id": 94318,
           *           "name": "Road Trip",
           *           "description": "",
           *           "updated_at": "2025-02-28T09:50:03.238Z",
           *           "created_at": "2025-01-28T09:50:03.238Z",
           *           "text_color": "333",
           *           "background_color": "CFF4F3",
           *           "archived": false,
           *           "archived_at": null
           *         },
           *         {
           *           "id": 94319,
           *           "name": "Date Night",
           *           "description": "",
           *           "updated_at": "2025-02-28T09:59:03.238Z",
           *           "created_at": "2025-01-28T10:02:03.238Z",
           *           "text_color": "333",
           *           "background_color": "D7F5CC",
           *           "archived": false,
           *           "archived_at": null
           *         }
           *       ]
           *     }
           */
          "application/json": {
            tags?: components["schemas"]["tagObject"][];
          };
        };
      };
      /** @description Invalid request parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be equal to one of the allowed values",
           *           "instancePath": "/query/format",
           *           "schemaPath": "#/properties/query/properties/format/enum",
           *           "keyword": "enum",
           *           "params": {
           *             "allowedValues": [
           *               "flattened",
           *               "nested"
           *             ]
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  createTag: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["createTagRequestObject"];
      };
    };
    responses: {
      /** @description Tag Object with the successfully created tag */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tagObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Invalid Request Body",
           *       "errors": [
           *         {
           *           "errMsg": "Tag with name 'New Tag' already exists"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getTagById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the tag to retrieve */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Tag Object with the requested Tag ID */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "id": 94319,
           *       "name": "Date Night",
           *       "description": "",
           *       "updated_at": "2025-02-28T09:59:03.238Z",
           *       "created_at": "2025-01-28T10:02:03.238Z",
           *       "text_color": null,
           *       "background_color": null,
           *       "archived": false,
           *       "archived_at": null
           *     }
           */
          "application/json": components["schemas"]["tagObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be a valid integer",
           *           "instancePath": "/query/ids/0",
           *           "schemaPath": "#/properties/query/properties/ids/items/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no tag with the id:'543210'"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  updateTag: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the tag to update */
        id: number;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["updateTagRequestObject"];
      };
    };
    responses: {
      /** @description Category or Category Group updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["tagObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Invalid Request Body",
           *       "errors": [
           *         {
           *           "errMsg": "A request to update a tag must include at least one of the following properties: name, description, archived"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no tag with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  deleteTag: {
    parameters: {
      query?: {
        /** @description Set to true to force deletion even if there are dependencies */
        force?: boolean;
      };
      header?: never;
      path: {
        /** @description ID of the tag to delete */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no tag with the id:'543210'`"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "tag_name": "Tag to be Deleted",
           *       "dependents": {
           *         "rules": 1,
           *         "transactions": 10
           *       }
           *     }
           */
          "application/json": components["schemas"]["deleteTagResponseWithDependencies"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getAllRecurring: {
    parameters: {
      query?: {
        /** @description Denotes the beginning of the range used to populate the `matching` object in the recurring items. If omitted, the current month will be used as the range.<br> Required if end_date exists. */
        start_date?: string;
        /** @description Denotes the end of the the range used to populate the `matching` object in the recurring items. Required if start_date exists. */
        end_date?: string;
        include_suggested?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A list of recurring items */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "recurring_items": {
           *         "recurring_items": [
           *           {
           *             "id": 994069,
           *             "description": "Income",
           *             "status": "reviewed",
           *             "transaction_criteria": {
           *               "start_date": "2024-09-01",
           *               "end_date": "2024-10-31",
           *               "anchor_date": "2024-09-14",
           *               "granularity": "month",
           *               "quantity": 1,
           *               "payee": "Penny Lane",
           *               "amount": "1250.8400",
           *               "to_base": 1250.84,
           *               "currency": "usd",
           *               "plaid_account_id": 119806,
           *               "manual_account_id": null
           *             },
           *             "overrides": {
           *               "payee": "Paycheck",
           *               "category_id": 88
           *             },
           *             "matches": {
           *               "request_start_date": "2024-10-01",
           *               "request_end_date": "2024-10-31",
           *               "expected_occurrence_dates": [
           *                 "2024-10-14",
           *                 "2024-10-28"
           *               ],
           *               "found_transactions": [
           *                 {
           *                   "date": "2024-10-14",
           *                   "transaction_id": 2212150658
           *                 }
           *               ],
           *               "missing_transaction_dates": [
           *                 "2024-10-28"
           *               ]
           *             },
           *             "created_by": 18328,
           *             "created_at": "2024-07-28T01:01:38.716Z",
           *             "updated_at": "2024-07-28T01:01:38.716Z",
           *             "source": "manual"
           *           },
           *           {
           *             "id": 994079,
           *             "description": "Monthly rent payable to Mrs Smith",
           *             "status": "reviewed",
           *             "transaction_criteria": {
           *               "start_date": "2024-09-01",
           *               "end_date": "2024-10-31",
           *               "anchor_date": "2024-09-01",
           *               "granularity": "month",
           *               "quantity": 1,
           *               "payee": "[No Payee]",
           *               "amount": "850.0000",
           *               "to_base": 850,
           *               "currency": "usd",
           *               "plaid_account_id": 119806,
           *               "manual_account_id": null
           *             },
           *             "overrides": {
           *               "payee": "Rent",
           *               "notes": "Monthly rent payable to Mrs Smith",
           *               "category_id": 83
           *             },
           *             "matches": {
           *               "request_start_date": "2024-10-01",
           *               "request_end_date": "2024-10-31",
           *               "expected_occurrence_dates": [
           *                 "2024-10-01"
           *               ],
           *               "found_transactions": [
           *                 {
           *                   "date": "2024-10-01",
           *                   "transaction_id": 2212150656
           *                 }
           *               ],
           *               "missing_transaction_dates": []
           *             },
           *             "created_by": 18328,
           *             "created_at": "2025-06-28T01:01:38.195Z",
           *             "updated_at": "2025-06-28T01:01:38.195Z",
           *             "source": "manual"
           *           }
           *         ]
           *       }
           *     }
           */
          "application/json": {
            recurring_items?: components["schemas"]["recurringObject"][];
          };
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be a valid integer",
           *           "instancePath": "/query/ids/0",
           *           "schemaPath": "#/properties/query/properties/ids/items/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no tag with the id:'543210'"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
  getRecurringById: {
    parameters: {
      query?: {
        /** @description Denotes the beginning of the range used to populate the `matching` object in the recurring items. If omitted, the current month will be used as the range.<br> Required if end_date exists. */
        start_date?: string;
        /** @description Denotes the end of the the range used to populate the `matching` object in the recurring items. Required if start_date exists. */
        end_date?: string;
      };
      header?: never;
      path: {
        /** @description ID of the recurring item to retrieve */
        id: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Tag Object with the requested Tag ID */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "id": 994069,
           *       "description": "Income",
           *       "status": "reviewed",
           *       "transaction_criteria": {
           *         "start_date": "2024-09-01",
           *         "end_date": "2024-10-31",
           *         "anchor_date": "2024-09-14",
           *         "granularity": "month",
           *         "quantity": 1,
           *         "payee": "Penny Lane",
           *         "amount": "1250.8400",
           *         "to_base": 1250.84,
           *         "currency": "usd",
           *         "plaid_account_id": 119806,
           *         "manual_account_id": null
           *       },
           *       "overrides": {
           *         "payee": "Paycheck",
           *         "category_id": 88
           *       },
           *       "matches": {
           *         "request_start_date": "2024-10-01",
           *         "request_end_date": "2024-10-31",
           *         "expected_occurrence_dates": [
           *           "2024-10-14",
           *           "2024-10-28"
           *         ],
           *         "found_transactions": [
           *           {
           *             "date": "2024-10-14",
           *             "transaction_id": 2212150658
           *           }
           *         ],
           *         "missing_transaction_dates": [
           *           "2024-10-28"
           *         ]
           *       },
           *       "created_by": 18328,
           *       "created_at": "2024-07-28T01:01:38.716Z",
           *       "updated_at": "2024-07-28T01:01:38.716Z",
           *       "source": "manual"
           *     }
           */
          "application/json": components["schemas"]["recurringObject"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Request Validation Failure",
           *       "errors": [
           *         {
           *           "errMsg": "must be a valid integer",
           *           "instancePath": "/query/ids/0",
           *           "schemaPath": "#/properties/query/properties/ids/items/type",
           *           "keyword": "type",
           *           "params": {
           *             "type": "integer"
           *           }
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      401: components["responses"]["unauthorizedToken"];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          /**
           * @example {
           *       "message": "Not Found",
           *       "errors": [
           *         {
           *           "errMsg": "There is no tag with the id:'543210'"
           *         }
           *       ]
           *     }
           */
          "application/json": components["schemas"]["errorResponseObject"];
        };
      };
      429: components["responses"]["rateLimited"];
      500: components["responses"]["serverError"];
    };
  };
}
